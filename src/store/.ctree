store/
├── hooks.ts
│       // src/store/hooks.ts
│       import { useCallback } from 'react'
│       import { StoreState, useStore } from './index'
│       import * as selectors from './selectors'
│       import {
│         Project,
│         ProjectFormData,
│         Objective,
│         ObjectiveFormData,
│         Task,
│         TaskFormData,
│         TodoList,
│         TodoListFormData,
│         TimeEntry,
│         TimeEntryFormData
│       } from '@/types'
│       
│       // Project Hook Return Types
│       interface UseProjectsReturn {
│         projects: Project[]
│         loading: boolean
│         error: Error | null
│         createProject: (data: ProjectFormData) => Promise<void>
│         updateProject: (id: string, data: Partial<ProjectFormData>) => Promise<void>
│         deleteProject: (id: string) => Promise<void>
│         fetchProjects: () => Promise<void>
│       }
│       
│       interface UseProjectReturn {
│         project: Project | undefined
│         projectWithDetails: ReturnType<typeof selectors.selectProjectWithDetails>
│         updateProject: (data: Partial<ProjectFormData>) => Promise<void>
│         deleteProject: () => Promise<void>
│       }
│       
│       // Objective Hook Return Types
│       interface UseObjectivesReturn {
│         objectives: Objective[]
│         loading: boolean
│         error: Error | null
│         createObjective: (data: ObjectiveFormData) => Promise<void>
│         updateObjective: (id: string, data: Partial<ObjectiveFormData>) => Promise<void>
│         deleteObjective: (id: string) => Promise<void>
│         fetchObjectives: () => Promise<void>
│       }
│       
│       interface UseObjectiveReturn {
│         objective: Objective | undefined
│         objectiveWithDetails: ReturnType<typeof selectors.selectObjectiveWithDetails>
│         updateObjective: (data: Partial<ObjectiveFormData>) => Promise<void>
│         deleteObjective: () => Promise<void>
│       }
│       
│       // Task Hook Return Types
│       interface UseTasksReturn {
│         tasks: Task[]
│         loading: boolean
│         error: Error | null
│         createTask: (data: TaskFormData) => Promise<void>
│         updateTask: (id: string, data: Partial<TaskFormData>) => Promise<void>
│         deleteTask: (id: string) => Promise<void>
│         fetchTasks: () => Promise<void>
│       }
│       
│       interface UseTaskReturn {
│         task: Task | undefined
│         updateTask: (data: Partial<TaskFormData>) => Promise<void>
│         deleteTask: () => Promise<void>
│       }
│       
│       // TodoList Hook Return Types
│       interface UseTodoListsReturn {
│         todoLists: TodoList[]
│         loading: boolean
│         error: Error | null
│         createTodoList: (data: TodoListFormData) => Promise<void>
│         updateTodoList: (id: string, data: Partial<TodoListFormData>) => Promise<void>
│         deleteTodoList: (id: string) => Promise<void>
│         fetchTodoLists: () => Promise<void>
│       }
│       
│       interface UseTodoListReturn {
│         todoList: TodoList | undefined
│         todoListWithTasks: (TodoList & { tasks: Task[] }) | undefined
│         updateTodoList: (data: Partial<TodoListFormData>) => Promise<void>
│         deleteTodoList: () => Promise<void>
│       }
│       
│       // TimeEntry Hook Return Types
│       interface UseTimeEntriesReturn {
│         timeEntries: TimeEntry[]
│         loading: boolean
│         error: Error | null
│         createTimeEntry: (data: TimeEntryFormData) => Promise<void>
│         updateTimeEntry: (id: string, data: Partial<TimeEntryFormData>) => Promise<void>
│         deleteTimeEntry: (id: string) => Promise<void>
│         fetchTimeEntries: () => Promise<void>
│       }
│       
│       interface UseTimeEntryReturn {
│         timeEntry: TimeEntry | undefined
│         updateTimeEntry: (data: Partial<TimeEntryFormData>) => Promise<void>
│         deleteTimeEntry: () => Promise<void>
│       }
│       
│       // Project Hooks
│       export const useProjects = (): UseProjectsReturn => {
│         const projects = useStore(selectors.selectProjects)
│         const loading = useStore(selectors.selectProjectsLoading)
│         const error = useStore(selectors.selectProjectsError)
│         const createProject = useStore((state) => state.createProject)
│         const updateProject = useStore((state) => state.updateProject)
│         const deleteProject = useStore((state) => state.deleteProject)
│         const fetchProjects = useStore((state) => state.fetchProjects)
│       
│         return {
│           projects,
│           loading,
│           error,
│           createProject,
│           updateProject,
│           deleteProject,
│           fetchProjects
│         }
│       }
│       
│       export const useProject = (id: string): UseProjectReturn => {
│         const project = useStore((state) => selectors.selectProjectById(state, id))
│         const projectWithDetails = useStore((state) => selectors.selectProjectWithDetails(state, id))
│         const updateProject = useStore((state) => state.updateProject)
│         const deleteProject = useStore((state) => state.deleteProject)
│       
│         return {
│           project,
│           projectWithDetails,
│           updateProject: useCallback(
│             (data: Partial<ProjectFormData>) => updateProject(id, data),
│             [id, updateProject]
│           ),
│           deleteProject: useCallback(
│             () => deleteProject(id),
│             [id, deleteProject]
│           )
│         }
│       }
│       
│       // Objective Hooks
│       export const useObjectives = (): UseObjectivesReturn => {
│         const objectives = useStore(selectors.selectObjectives)
│         const loading = useStore(selectors.selectObjectivesLoading)
│         const error = useStore(selectors.selectObjectivesError)
│         const createObjective = useStore((state) => state.createObjective)
│         const updateObjective = useStore((state) => state.updateObjective)
│         const deleteObjective = useStore((state) => state.deleteObjective)
│         const fetchObjectives = useStore((state) => state.fetchObjectives)
│       
│         return {
│           objectives,
│           loading,
│           error,
│           createObjective,
│           updateObjective,
│           deleteObjective,
│           fetchObjectives
│         }
│       }
│       
│       export const useObjective = (id: string): UseObjectiveReturn => {
│         const objective = useStore((state) => selectors.selectObjectiveById(state, id))
│         const objectiveWithDetails = useStore((state) => selectors.selectObjectiveWithDetails(state, id))
│         const updateObjective = useStore((state) => state.updateObjective)
│         const deleteObjective = useStore((state) => state.deleteObjective)
│       
│         return {
│           objective,
│           objectiveWithDetails,
│           updateObjective: useCallback(
│             (data: Partial<ObjectiveFormData>) => updateObjective(id, data),
│             [id, updateObjective]
│           ),
│           deleteObjective: useCallback(
│             () => deleteObjective(id),
│             [id, deleteObjective]
│           )
│         }
│       }
│       
│       // Task Hooks
│       export const useTasks = (): UseTasksReturn => {
│         const tasks = useStore(selectors.selectTasks)
│         const loading = useStore(selectors.selectTasksLoading)
│         const error = useStore(selectors.selectTasksError)
│         const createTask = useStore((state) => state.createTask)
│         const updateTask = useStore((state) => state.updateTask)
│         const deleteTask = useStore((state) => state.deleteTask)
│         const fetchTasks = useStore((state) => state.fetchTasks)
│       
│         return {
│           tasks,
│           loading,
│           error,
│           createTask,
│           updateTask,
│           deleteTask,
│           fetchTasks
│         }
│       }
│       
│       export const useTask = (id: string): UseTaskReturn => {
│         const task = useStore((state) => selectors.selectTaskById(state, id))
│         const updateTask = useStore((state) => state.updateTask)
│         const deleteTask = useStore((state) => state.deleteTask)
│       
│         return {
│           task,
│           updateTask: useCallback(
│             (data: Partial<TaskFormData>) => updateTask(id, data),
│             [id, updateTask]
│           ),
│           deleteTask: useCallback(
│             () => deleteTask(id),
│             [id, deleteTask]
│           )
│         }
│       }
│       
│       // TodoList Hooks
│       export const useTodoLists = (): UseTodoListsReturn => {
│         const todoLists = useStore(selectors.selectTodoLists)
│         const loading = useStore(selectors.selectTodoListsLoading)
│         const error = useStore(selectors.selectTodoListsError)
│         const createTodoList = useStore((state) => state.createTodoList)
│         const updateTodoList = useStore((state) => state.updateTodoList)
│         const deleteTodoList = useStore((state) => state.deleteTodoList)
│         const fetchTodoLists = useStore((state) => state.fetchTodoLists)
│       
│         return {
│           todoLists,
│           loading,
│           error,
│           createTodoList,
│           updateTodoList,
│           deleteTodoList,
│           fetchTodoLists
│         }
│       }
│       
│       export const useTodoList = (id: string): UseTodoListReturn => {
│         const todoList = useStore((state) => selectors.selectTodoListById(state, id))
│         const todoListWithTasks = useStore((state) => 
│           selectors.selectTodoListsWithTasks(state).find((list) => list.id === id)
│         )
│         const updateTodoList = useStore((state) => state.updateTodoList)
│         const deleteTodoList = useStore((state) => state.deleteTodoList)
│       
│         return {
│           todoList,
│           todoListWithTasks,
│           updateTodoList: useCallback(
│             (data: Partial<TodoListFormData>) => updateTodoList(id, data),
│             [id, updateTodoList]
│           ),
│           deleteTodoList: useCallback(
│             () => deleteTodoList(id),
│             [id, deleteTodoList]
│           )
│         }
│       }
│       
│       // TimeEntry Hooks
│       export const useTimeEntries = (): UseTimeEntriesReturn => {
│         const timeEntries = useStore(selectors.selectTimeEntries)
│         const loading = useStore(selectors.selectTimeEntriesLoading)
│         const error = useStore(selectors.selectTimeEntriesError)
│         const createTimeEntry = useStore((state) => state.createTimeEntry)
│         const updateTimeEntry = useStore((state) => state.updateTimeEntry)
│         const deleteTimeEntry = useStore((state) => state.deleteTimeEntry)
│         const fetchTimeEntries = useStore((state) => state.fetchTimeEntries)
│       
│         return {
│           timeEntries,
│           loading,
│           error,
│           createTimeEntry,
│           updateTimeEntry,
│           deleteTimeEntry,
│           fetchTimeEntries
│         }
│       }
│       
│       export const useTimeEntry = (id: string): UseTimeEntryReturn => {
│         const timeEntry = useStore((state) => selectors.selectTimeEntryById(state, id))
│         const updateTimeEntry = useStore((state) => state.updateTimeEntry)
│         const deleteTimeEntry = useStore((state) => state.deleteTimeEntry)
│       
│         return {
│           timeEntry,
│           updateTimeEntry: useCallback(
│             (data: Partial<TimeEntryFormData>) => updateTimeEntry(id, data),
│             [id, updateTimeEntry]
│           ),
│           deleteTimeEntry: useCallback(
│             () => deleteTimeEntry(id),
│             [id, deleteTimeEntry]
│           )
│         }
│       }
│       
│       // Global Hooks
│       interface UseStoreStatusReturn {
│         isLoading: boolean
│         hasError: boolean
│         clearErrors: () => void
│         refreshAll: () => Promise<void>
│       }
│       
│       export const useStoreStatus = (): UseStoreStatusReturn => {
│         const anyLoading = useStore(selectors.selectAnyLoading)
│         const anyError = useStore(selectors.selectAnyError)
│         const clearErrors = useStore((state) => state.clearErrors)
│         const refreshAll = useStore((state) => state.refreshAll)
│       
│         return {
│           isLoading: anyLoading,
│           hasError: !!anyError,
│           clearErrors,
│           refreshAll
│         }
│       }
├── index.ts
│       // src/store/index.ts
│       import { create } from 'zustand'
│       import { devtools, persist } from 'zustand/middleware'
│       import { 
│         Project, 
│         Objective, 
│         Task, 
│         TodoList, 
│         TimeEntry,
│         ProjectFormData,
│         ObjectiveFormData,
│         TaskFormData,
│         TodoListFormData,
│         TimeEntryFormData 
│       } from '@/types'
│       
│       // Import individual APIs instead of using barrel imports
│       import { projectsApi } from '@/lib/api/projects'
│       import { objectivesApi } from '@/lib/api/objectives'
│       import { tasksApi } from '@/lib/api/tasks'
│       import { todoListsApi } from '@/lib/api/todoLists'
│       import { timeEntriesApi } from '@/lib/api/timeEntries'
│       
│       // Project State
│       interface ProjectState {
│         projects: Project[]
│         projectsLoading: boolean
│         projectsError: Error | null
│         fetchProjects: () => Promise<void>
│         createProject: (data: ProjectFormData) => Promise<void>
│         updateProject: (id: string, data: Partial<ProjectFormData>) => Promise<void>
│         deleteProject: (id: string) => Promise<void>
│       }
│       
│       // Objective State
│       interface ObjectiveState {
│         objectives: Objective[]
│         objectivesLoading: boolean
│         objectivesError: Error | null
│         fetchObjectives: () => Promise<void>
│         createObjective: (data: ObjectiveFormData) => Promise<void>
│         updateObjective: (id: string, data: Partial<ObjectiveFormData>) => Promise<void>
│         deleteObjective: (id: string) => Promise<void>
│       }
│       
│       // Task State
│       interface TaskState {
│         tasks: Task[]
│         tasksLoading: boolean
│         tasksError: Error | null
│         fetchTasks: () => Promise<void>
│         createTask: (data: TaskFormData) => Promise<void>
│         updateTask: (id: string, data: Partial<TaskFormData>) => Promise<void>
│         deleteTask: (id: string) => Promise<void>
│       }
│       
│       // TodoList State
│       interface TodoListState {
│         todoLists: TodoList[]
│         todoListsLoading: boolean
│         todoListsError: Error | null
│         fetchTodoLists: () => Promise<void>
│         createTodoList: (data: TodoListFormData) => Promise<void>
│         updateTodoList: (id: string, data: Partial<TodoListFormData>) => Promise<void>
│         deleteTodoList: (id: string) => Promise<void>
│       }
│       
│       // TimeEntry State
│       interface TimeEntryState {
│         timeEntries: TimeEntry[]
│         timeEntriesLoading: boolean
│         timeEntriesError: Error | null
│         fetchTimeEntries: () => Promise<void>
│         createTimeEntry: (data: TimeEntryFormData) => Promise<void>
│         updateTimeEntry: (id: string, data: Partial<TimeEntryFormData>) => Promise<void>
│         deleteTimeEntry: (id: string) => Promise<void>
│       }
│       
│       // Global Actions
│       interface GlobalActions {
│         refreshAll: () => Promise<void>
│         clearErrors: () => void
│       }
│       
│       // Combined Store State
│       export interface StoreState extends 
│         ProjectState, 
│         ObjectiveState, 
│         TaskState, 
│         TodoListState, 
│         TimeEntryState,
│         GlobalActions {}
│       
│       // Middleware Options Types
│       interface PersistOptions {
│         name: string
│         partialize: (state: StoreState) => Partial<StoreState>
│       }
│       
│       // Create the store
│       export const useStore = create<StoreState>()(
│         devtools(
│           persist(
│             (set, get) => ({
│               // Project State Implementation
│               projects: [],
│               projectsLoading: false,
│               projectsError: null,
│               fetchProjects: async () => {
│                 set({ projectsLoading: true })
│                 try {
│                   const projects = await projectsApi.getProjects()
│                   set({ projects, projectsError: null })
│                 } catch (error) {
│                   set({ projectsError: error as Error })
│                 } finally {
│                   set({ projectsLoading: false })
│                 }
│               },
│               createProject: async (data: ProjectFormData) => {
│                 set({ projectsLoading: true })
│                 try {
│                   const newProject = await projectsApi.createProject(data)
│                   set((state) => ({ 
│                     projects: [...state.projects, newProject],
│                     projectsError: null 
│                   }))
│                 } catch (error) {
│                   set({ projectsError: error as Error })
│                 } finally {
│                   set({ projectsLoading: false })
│                 }
│               },
│               updateProject: async (id: string, data: Partial<ProjectFormData>) => {
│                 set({ projectsLoading: true })
│                 try {
│                   const updatedProject = await projectsApi.updateProject(id, data)
│                   set((state) => ({
│                     projects: state.projects.map((p) => 
│                       p.id === id ? updatedProject : p
│                     ),
│                     projectsError: null
│                   }))
│                 } catch (error) {
│                   set({ projectsError: error as Error })
│                 } finally {
│                   set({ projectsLoading: false })
│                 }
│               },
│               deleteProject: async (id: string) => {
│                 set({ projectsLoading: true })
│                 try {
│                   await projectsApi.deleteProject(id)
│                   set((state) => ({
│                     projects: state.projects.filter((p) => p.id !== id),
│                     projectsError: null
│                   }))
│                 } catch (error) {
│                   set({ projectsError: error as Error })
│                 } finally {
│                   set({ projectsLoading: false })
│                 }
│               },
│       
│               // Objective State Implementation
│               objectives: [],
│               objectivesLoading: false,
│               objectivesError: null,
│               fetchObjectives: async () => {
│                 set({ objectivesLoading: true })
│                 try {
│                   const objectives = await objectivesApi.getObjectives()
│                   set({ objectives, objectivesError: null })
│                 } catch (error) {
│                   set({ objectivesError: error as Error })
│                 } finally {
│                   set({ objectivesLoading: false })
│                 }
│               },
│               createObjective: async (data: ObjectiveFormData) => {
│                 set({ objectivesLoading: true })
│                 try {
│                   const newObjective = await objectivesApi.createObjective(data)
│                   set((state) => ({
│                     objectives: [...state.objectives, newObjective],
│                     objectivesError: null
│                   }))
│                 } catch (error) {
│                   set({ objectivesError: error as Error })
│                 } finally {
│                   set({ objectivesLoading: false })
│                 }
│               },
│               updateObjective: async (id: string, data: Partial<ObjectiveFormData>) => {
│                 set({ objectivesLoading: true })
│                 try {
│                   const updatedObjective = await objectivesApi.updateObjective(id, data)
│                   set((state) => ({
│                     objectives: state.objectives.map((o) =>
│                       o.id === id ? updatedObjective : o
│                     ),
│                     objectivesError: null
│                   }))
│                 } catch (error) {
│                   set({ objectivesError: error as Error })
│                 } finally {
│                   set({ objectivesLoading: false })
│                 }
│               },
│               deleteObjective: async (id: string) => {
│                 set({ objectivesLoading: true })
│                 try {
│                   await objectivesApi.deleteObjective(id)
│                   set((state) => ({
│                     objectives: state.objectives.filter((o) => o.id !== id),
│                     objectivesError: null
│                   }))
│                 } catch (error) {
│                   set({ objectivesError: error as Error })
│                 } finally {
│                   set({ objectivesLoading: false })
│                 }
│               },
│       
│               // Task State Implementation
│               tasks: [],
│               tasksLoading: false,
│               tasksError: null,
│               fetchTasks: async () => {
│                 set({ tasksLoading: true })
│                 try {
│                   const tasks = await tasksApi.getTasks()
│                   set({ tasks, tasksError: null })
│                 } catch (error) {
│                   set({ tasksError: error as Error })
│                 } finally {
│                   set({ tasksLoading: false })
│                 }
│               },
│               createTask: async (data: TaskFormData) => {
│                 set({ tasksLoading: true })
│                 try {
│                   const newTask = await tasksApi.createTask(data)
│                   set((state) => ({
│                     tasks: [...state.tasks, newTask],
│                     tasksError: null
│                   }))
│                 } catch (error) {
│                   set({ tasksError: error as Error })
│                 } finally {
│                   set({ tasksLoading: false })
│                 }
│               },
│               updateTask: async (id: string, data: Partial<TaskFormData>) => {
│                 set({ tasksLoading: true })
│                 try {
│                   const updatedTask = await tasksApi.updateTask(id, data)
│                   set((state) => ({
│                     tasks: state.tasks.map((t) =>
│                       t.id === id ? updatedTask : t
│                     ),
│                     tasksError: null
│                   }))
│                 } catch (error) {
│                   set({ tasksError: error as Error })
│                 } finally {
│                   set({ tasksLoading: false })
│                 }
│               },
│               deleteTask: async (id: string) => {
│                 set({ tasksLoading: true })
│                 try {
│                   await tasksApi.deleteTask(id)
│                   set((state) => ({
│                     tasks: state.tasks.filter((t) => t.id !== id),
│                     tasksError: null
│                   }))
│                 } catch (error) {
│                   set({ tasksError: error as Error })
│                 } finally {
│                   set({ tasksLoading: false })
│                 }
│               },
│       
│               // TodoList State Implementation
│               todoLists: [],
│               todoListsLoading: false,
│               todoListsError: null,
│               fetchTodoLists: async () => {
│                 set({ todoListsLoading: true })
│                 try {
│                   const todoLists = await todoListsApi.getTodoLists()
│                   set({ todoLists, todoListsError: null })
│                 } catch (error) {
│                   set({ todoListsError: error as Error })
│                 } finally {
│                   set({ todoListsLoading: false })
│                 }
│               },
│               createTodoList: async (data: TodoListFormData) => {
│                 set({ todoListsLoading: true })
│                 try {
│                   const newTodoList = await todoListsApi.createTodoList(data)
│                   set((state) => ({
│                     todoLists: [...state.todoLists, newTodoList],
│                     todoListsError: null
│                   }))
│                 } catch (error) {
│                   set({ todoListsError: error as Error })
│                 } finally {
│                   set({ todoListsLoading: false })
│                 }
│               },
│               updateTodoList: async (id: string, data: Partial<TodoListFormData>) => {
│                 set({ todoListsLoading: true })
│                 try {
│                   const updatedTodoList = await todoListsApi.updateTodoList(id, data)
│                   set((state) => ({
│                     todoLists: state.todoLists.map((t) =>
│                       t.id === id ? updatedTodoList : t
│                     ),
│                     todoListsError: null
│                   }))
│                 } catch (error) {
│                   set({ todoListsError: error as Error })
│                 } finally {
│                   set({ todoListsLoading: false })
│                 }
│               },
│               deleteTodoList: async (id: string) => {
│                 set({ todoListsLoading: true })
│                 try {
│                   await todoListsApi.deleteTodoList(id)
│                   set((state) => ({
│                     todoLists: state.todoLists.filter((t) => t.id !== id),
│                     todoListsError: null
│                   }))
│                 } catch (error) {
│                   set({ todoListsError: error as Error })
│                 } finally {
│                   set({ todoListsLoading: false })
│                 }
│               },
│       
│               // TimeEntry State Implementation
│               timeEntries: [],
│               timeEntriesLoading: false,
│               timeEntriesError: null,
│               fetchTimeEntries: async () => {
│                 set({ timeEntriesLoading: true })
│                 try {
│                   const timeEntries = await timeEntriesApi.getTimeEntries()
│                   set({ timeEntries, timeEntriesError: null })
│                 } catch (error) {
│                   set({ timeEntriesError: error as Error })
│                 } finally {
│                   set({ timeEntriesLoading: false })
│                 }
│               },
│               createTimeEntry: async (data: TimeEntryFormData) => {
│                 set({ timeEntriesLoading: true })
│                 try {
│                   const newTimeEntry = await timeEntriesApi.createTimeEntry(data)
│                   set((state) => ({
│                     timeEntries: [...state.timeEntries, newTimeEntry],
│                     timeEntriesError: null
│                   }))
│                 } catch (error) {
│                   set({ timeEntriesError: error as Error })
│                 } finally {
│                   set({ timeEntriesLoading: false })
│                 }
│               },
│               updateTimeEntry: async (id: string, data: Partial<TimeEntryFormData>) => {
│                 set({ timeEntriesLoading: true })
│                 try {
│                   const updatedTimeEntry = await timeEntriesApi.updateTimeEntry(id, data)
│                   set((state) => ({
│                     timeEntries: state.timeEntries.map((t) =>
│                       t.id === id ? updatedTimeEntry : t
│                     ),
│                     timeEntriesError: null
│                   }))
│                 } catch (error) {
│                   set({ timeEntriesError: error as Error })
│                 } finally {
│                   set({ timeEntriesLoading: false })
│                 }
│               },
│               deleteTimeEntry: async (id: string) => {
│                 set({ timeEntriesLoading: true })
│                 try {
│                   await timeEntriesApi.deleteTimeEntry(id)
│                   set((state) => ({
│                     timeEntries: state.timeEntries.filter((t) => t.id !== id),
│                     timeEntriesError: null
│                   }))
│                 } catch (error) {
│                   set({ timeEntriesError: error as Error })
│                 } finally {
│                   set({ timeEntriesLoading: false })
│                 }
│               },
│       
│               // Global Actions Implementation
│               refreshAll: async () => {
│                 await Promise.all([
│                   get().fetchProjects(),
│                   get().fetchObjectives(),
│                   get().fetchTasks(),
│                   get().fetchTodoLists(),
│                   get().fetchTimeEntries()
│                 ])
│               },
│               clearErrors: () => {
│                 set({
│                   projectsError: null,
│                   objectivesError: null,
│                   tasksError: null,
│                   todoListsError: null,
│                   timeEntriesError: null
│                 })
│               }
│             }),
│             {
│               name: 'project-management-store',
│               partialize: (state) => ({
│                 projects: state.projects,
│                 objectives: state.objectives,
│                 tasks: state.tasks,
│                 todoLists: state.todoLists,
│                 timeEntries: state.timeEntries
│               })
│             } as PersistOptions
│           )
│         )
│       )
├── selectors/
│   ├── index.ts
│   │       
│   │       // src/store/selectors/index.ts
│   │       export * from './projects';
│   │       export * from './tasks';
│   │       // Export other selectors...
│   ├── objectives.ts
│   ├── projects.ts
│   │       
│   │       // src/store/selectors/projects.ts
│   │       import { StoreState } from '../types';
│   │       import { Project } from '@/types';
│   │       
│   │       export const selectProjects = (state: StoreState): Project[] => state.projects;
│   │       export const selectProjectById = (state: StoreState, id: string): Project | undefined =>
│   │         state.projects.find((p) => p.id === id);
│   │       export const selectProjectsLoading = (state: StoreState): boolean => state.projectsLoading;
│   │       export const selectProjectsError = (state: StoreState): Error | null => state.projectsError;
│   ├── tasks.ts
│   │       
│   │       // src/store/selectors/tasks.ts
│   │       import { StoreState } from '../types';
│   │       import { Task } from '@/types';
│   │       
│   │       export const selectTasks = (state: StoreState): Task[] => state.tasks;
│   │       export const selectTaskById = (state: StoreState, id: string): Task | undefined =>
│   │         state.tasks.find((t) => t.id === id);
│   │       export const selectTasksLoading = (state: StoreState): boolean => state.tasksLoading;
│   │       export const selectTasksError = (state: StoreState): Error | null => state.tasksError;
│   │       export const selectTaskComplete = (state: StoreState, id: string): boolean =>
│   │         selectTaskById(state, id)?.status === 'done';
│   ├── timeEntries.ts
│   └── todoLists.ts
├── selectors.ts
│       // src/store/selectors.ts
│       import { StoreState } from './index'
│       import {
│         Project,
│         Objective,
│         Task,
│         TodoList,
│         TimeEntry,
│         Status,
│         Priority
│       } from '@/types'
│       
│       // Project Selectors
│       export const selectProjects = (state: StoreState): Project[] => state.projects
│       
│       export const selectProjectById = (state: StoreState, id: string): Project | undefined => 
│         state.projects.find((p: Project) => p.id === id)
│       
│       export const selectActiveProjects = (state: StoreState): Project[] =>
│         state.projects.filter((p: Project) => p.status === 'active')
│       
│       export const selectProjectsLoading = (state: StoreState): boolean => state.projectsLoading
│       
│       export const selectProjectsError = (state: StoreState): Error | null => state.projectsError
│       
│       // Objective Selectors
│       export const selectObjectives = (state: StoreState): Objective[] => state.objectives
│       
│       export const selectObjectiveById = (state: StoreState, id: string): Objective | undefined =>
│         state.objectives.find((o: Objective) => o.id === id)
│       
│       export const selectObjectivesByProject = (state: StoreState, projectId: string): Objective[] =>
│         state.objectives.filter((o: Objective) => o.projectId === projectId)
│       
│       export const selectActiveObjectives = (state: StoreState): Objective[] =>
│         state.objectives.filter((o: Objective) => o.status === 'active')
│       
│       export const selectObjectivesLoading = (state: StoreState): boolean => state.objectivesLoading
│       
│       export const selectObjectivesError = (state: StoreState): Error | null => state.objectivesError
│       
│       // Task Selectors
│       export const selectTasks = (state: StoreState): Task[] => state.tasks
│       
│       export const selectTaskById = (state: StoreState, id: string): Task | undefined =>
│         state.tasks.find((t: Task) => t.id === id)
│       
│       export const selectTasksByProject = (state: StoreState, projectId: string): Task[] =>
│         state.tasks.filter((t: Task) => t.projectId === projectId)
│       
│       export const selectTasksByObjective = (state: StoreState, objectiveId: string): Task[] =>
│         state.tasks.filter((t: Task) => t.objectiveId === objectiveId)
│       
│       export const selectTasksByStatus = (state: StoreState, status: Status): Task[] =>
│         state.tasks.filter((t: Task) => t.status === status)
│       
│       export const selectTasksByPriority = (state: StoreState, priority: Priority): Task[] =>
│         state.tasks.filter((t: Task) => t.priority === priority)
│       
│       export const selectIncompleteTasks = (state: StoreState): Task[] =>
│         state.tasks.filter((t: Task) => t.status !== 'done')
│       
│       export const selectTasksLoading = (state: StoreState): boolean => state.tasksLoading
│       
│       export const selectTasksError = (state: StoreState): Error | null => state.tasksError
│       
│       // TodoList Selectors
│       export const selectTodoLists = (state: StoreState): TodoList[] => state.todoLists
│       
│       export const selectTodoListById = (state: StoreState, id: string): TodoList | undefined =>
│         state.todoLists.find((t: TodoList) => t.id === id)
│       
│       export interface TodoListWithTasks extends TodoList {
│         tasks: Task[]
│       }
│       
│       export const selectTodoListsByType = (state: StoreState, type: string): TodoList[] =>
│         state.todoLists.filter((t: TodoList) => t.type === type)
│       
│       export const selectTodoListsWithTasks = (state: StoreState): TodoListWithTasks[] =>
│         state.todoLists.map((list: TodoList) => ({
│           ...list,
│           tasks: state.tasks.filter((task: Task) => 
│             list.tasks?.some((t: Task) => t.id === task.id)
│           )
│         }))
│       
│       export const selectTodoListsLoading = (state: StoreState): boolean => state.todoListsLoading
│       
│       export const selectTodoListsError = (state: StoreState): Error | null => state.todoListsError
│       
│       // TimeEntry Selectors
│       export const selectTimeEntries = (state: StoreState): TimeEntry[] => state.timeEntries
│       
│       export const selectTimeEntryById = (state: StoreState, id: string): TimeEntry | undefined =>
│         state.timeEntries.find((t: TimeEntry) => t.id === id)
│       
│       export const selectTimeEntriesByTask = (state: StoreState, taskId: string): TimeEntry[] =>
│         state.timeEntries.filter((t: TimeEntry) => t.taskId === taskId)
│       
│       export const selectTimeEntriesByDate = (state: StoreState, date: Date): TimeEntry[] =>
│         state.timeEntries.filter((t: TimeEntry) => {
│           const entryDate = new Date(t.startTime)
│           return (
│             entryDate.getFullYear() === date.getFullYear() &&
│             entryDate.getMonth() === date.getMonth() &&
│             entryDate.getDate() === date.getDate()
│           )
│         })
│       
│       export const selectTimeEntriesByDateRange = (
│         state: StoreState, 
│         startDate: Date, 
│         endDate: Date
│       ): TimeEntry[] =>
│         state.timeEntries.filter((t: TimeEntry) => {
│           const entryDate = new Date(t.startTime)
│           return entryDate >= startDate && entryDate <= endDate
│         })
│       
│       export const selectTotalTimeSpent = (state: StoreState): number =>
│         state.timeEntries.reduce((total: number, entry: TimeEntry) => {
│           if (!entry.duration) return total
│           return total + entry.duration
│         }, 0)
│       
│       export const selectTimeEntriesLoading = (state: StoreState): boolean => 
│         state.timeEntriesLoading
│       
│       export const selectTimeEntriesError = (state: StoreState): Error | null => 
│         state.timeEntriesError
│       
│       // Combined Selectors
│       interface ProjectWithDetails extends Project {
│         objectives: Objective[]
│         tasks: Task[]
│         timeSpent: number
│       }
│       
│       interface ObjectiveWithProgress extends Objective {
│         tasks: Task[]
│         progress: {
│           total: number
│           completed: number
│           inProgress: number
│         }
│       }
│       
│       export const selectProjectWithDetails = (
│         state: StoreState, 
│         projectId: string
│       ): ProjectWithDetails | null => {
│         const project = selectProjectById(state, projectId)
│         if (!project) return null
│       
│         return {
│           ...project,
│           objectives: selectObjectivesByProject(state, projectId),
│           tasks: selectTasksByProject(state, projectId),
│           timeSpent: selectTimeEntriesByDateRange(
│             state,
│             project.startDate || new Date(0),
│             project.dueDate || new Date()
│           ).reduce((total: number, entry: TimeEntry) => total + (entry.duration || 0), 0)
│         }
│       }
│       
│       export const selectObjectiveWithDetails = (
│         state: StoreState, 
│         objectiveId: string
│       ): ObjectiveWithProgress | null => {
│         const objective = selectObjectiveById(state, objectiveId)
│         if (!objective) return null
│       
│         const tasks = selectTasksByObjective(state, objectiveId)
│         return {
│           ...objective,
│           tasks,
│           progress: {
│             total: tasks.length,
│             completed: tasks.filter((t: Task) => t.status === 'done').length,
│             inProgress: tasks.filter((t: Task) => t.status === 'in-progress').length
│           }
│         }
│       }
│       
│       // Loading States
│       export const selectAnyLoading = (state: StoreState): boolean =>
│         state.projectsLoading ||
│         state.objectivesLoading ||
│         state.tasksLoading ||
│         state.todoListsLoading ||
│         state.timeEntriesLoading
│       
│       // Error States
│       export const selectAnyError = (state: StoreState): Error | null =>
│         state.projectsError ||
│         state.objectivesError ||
│         state.tasksError ||
│         state.todoListsError ||
│         state.timeEntriesError
├── slices/
│   ├── objectives.ts
│   ├── project.ts
│   │       // src/store/slices/projects.ts
│   │       import { StateCreator } from 'zustand';
│   │       import { Project, ProjectFormData } from '@/types';
│   │       import { projectsApi } from '@/lib/api/projects';
│   │       
│   │       export interface ProjectSlice {
│   │         projects: Project[];
│   │         projectsLoading: boolean;
│   │         projectsError: Error | null;
│   │         fetchProjects: () => Promise<void>;
│   │         createProject: (data: ProjectFormData) => Promise<void>;
│   │         updateProject: (id: string, data: Partial<ProjectFormData>) => Promise<void>;
│   │         deleteProject: (id: string) => Promise<void>;
│   │       }
│   │       
│   │       export const createProjectSlice: StateCreator<ProjectSlice> = (set) => ({
│   │         projects: [],
│   │         projectsLoading: false,
│   │         projectsError: null,
│   │         fetchProjects: async () => {
│   │           set({ projectsLoading: true });
│   │           try {
│   │             const projects = await projectsApi.getProjects();
│   │             set({ projects, projectsError: null });
│   │           } catch (error) {
│   │             set({ projectsError: error as Error });
│   │           } finally {
│   │             set({ projectsLoading: false });
│   │           }
│   │         },
│   │         createProject: async (data) => {
│   │           set({ projectsLoading: true });
│   │           try {
│   │             const newProject = await projectsApi.createProject(data);
│   │             set((state) => ({
│   │               projects: [...state.projects, newProject],
│   │               projectsError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ projectsError: error as Error });
│   │           } finally {
│   │             set({ projectsLoading: false });
│   │           }
│   │         },
│   │         updateProject: async (id, data) => {
│   │           set({ projectsLoading: true });
│   │           try {
│   │             const updatedProject = await projectsApi.updateProject(id, data);
│   │             set((state) => ({
│   │               projects: state.projects.map((p) => p.id === id ? updatedProject : p),
│   │               projectsError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ projectsError: error as Error });
│   │           } finally {
│   │             set({ projectsLoading: false });
│   │           }
│   │         },
│   │         deleteProject: async (id) => {
│   │           set({ projectsLoading: true });
│   │           try {
│   │             await projectsApi.deleteProject(id);
│   │             set((state) => ({
│   │               projects: state.projects.filter((p) => p.id !== id),
│   │               projectsError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ projectsError: error as Error });
│   │           } finally {
│   │             set({ projectsLoading: false });
│   │           }
│   │         },
│   │       });
│   ├── tasks.ts
│   │       
│   │       // src/store/slices/tasks.ts
│   │       import { StateCreator } from 'zustand';
│   │       import { Task, TaskFormData } from '@/types';
│   │       import { tasksApi } from '@/lib/api/tasks';
│   │       
│   │       export interface TaskSlice {
│   │         tasks: Task[];
│   │         tasksLoading: boolean;
│   │         tasksError: Error | null;
│   │         fetchTasks: () => Promise<void>;
│   │         createTask: (data: TaskFormData) => Promise<void>;
│   │         updateTask: (id: string, data: Partial<TaskFormData>) => Promise<void>;
│   │         deleteTask: (id: string) => Promise<void>;
│   │         markTaskComplete: (id: string) => Promise<void>;
│   │       }
│   │       
│   │       export const createTaskSlice: StateCreator<TaskSlice> = (set) => ({
│   │         tasks: [],
│   │         tasksLoading: false,
│   │         tasksError: null,
│   │         fetchTasks: async () => {
│   │           set({ tasksLoading: true });
│   │           try {
│   │             const tasks = await tasksApi.getTasks();
│   │             set({ tasks, tasksError: null });
│   │           } catch (error) {
│   │             set({ tasksError: error as Error });
│   │           } finally {
│   │             set({ tasksLoading: false });
│   │           }
│   │         },
│   │         createTask: async (data) => {
│   │           set({ tasksLoading: true });
│   │           try {
│   │             const newTask = await tasksApi.createTask(data);
│   │             set((state) => ({
│   │               tasks: [...state.tasks, newTask],
│   │               tasksError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ tasksError: error as Error });
│   │           } finally {
│   │             set({ tasksLoading: false });
│   │           }
│   │         },
│   │         updateTask: async (id, data) => {
│   │           set({ tasksLoading: true });
│   │           try {
│   │             const updatedTask = await tasksApi.updateTask(id, data);
│   │             set((state) => ({
│   │               tasks: state.tasks.map((t) => t.id === id ? updatedTask : t),
│   │               tasksError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ tasksError: error as Error });
│   │           } finally {
│   │             set({ tasksLoading: false });
│   │           }
│   │         },
│   │         deleteTask: async (id) => {
│   │           set({ tasksLoading: true });
│   │           try {
│   │             await tasksApi.deleteTask(id);
│   │             set((state) => ({
│   │               tasks: state.tasks.filter((t) => t.id !== id),
│   │               tasksError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ tasksError: error as Error });
│   │           } finally {
│   │             set({ tasksLoading: false });
│   │           }
│   │         },
│   │         markTaskComplete: async (id) => {
│   │           set({ tasksLoading: true });
│   │           try {
│   │             const updatedTask = await tasksApi.markComplete(id);
│   │             set((state) => ({
│   │               tasks: state.tasks.map((t) => t.id === id ? updatedTask : t),
│   │               tasksError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ tasksError: error as Error });
│   │             throw error;
│   │           } finally {
│   │             set({ tasksLoading: false });
│   │           }
│   │         },
│   │       });
│   ├── timeEntries.ts
│   └── todoLists.ts
└── types.ts
