store/
├── hooks.ts
│       // src/store/hooks.ts
│       import { useCallback } from 'react'
│       import { useStore } from './index'
│       import * as selectors from './selectors'
│       import {
│         Project,
│         ProjectFormData,
│         Objective,
│         ObjectiveFormData,
│         Task,
│         TaskFormData,
│         TodoList,
│         TodoListFormData,
│         TimeEntry,
│         TimeEntryFormData
│       } from '@/types'
│       
│       interface UseTasksReturn {
│         tasks: Task[];
│         loading: boolean;
│         error: Error | null;
│         createTask: (data: TaskFormData) => Promise<void>;
│         updateTask: (id: string, data: Partial<TaskFormData>) => Promise<void>;
│         deleteTask: (id: string) => Promise<void>;
│         fetchTasks: () => Promise<void>;
│         markTaskComplete: (id: string) => Promise<void>;
│       }
│       
│       export const useTasks = (): UseTasksReturn => {
│         const tasks = useStore(selectors.selectTasks);
│         const loading = useStore(selectors.selectTasksLoading);
│         const error = useStore(selectors.selectTasksError);
│         const createTask = useStore((state) => state.createTask);
│         const updateTask = useStore((state) => state.updateTask);
│         const deleteTask = useStore((state) => state.deleteTask);
│         const fetchTasks = useStore((state) => state.fetchTasks);
│         const markTaskComplete = useStore((state) => state.markTaskComplete);
│       
│         return {
│           tasks,
│           loading,
│           error,
│           createTask,
│           updateTask,
│           deleteTask,
│           fetchTasks,
│           markTaskComplete,
│         };
│       };
│       
│       
│       // Project Hook Return Types
│       interface UseProjectsReturn {
│         projects: Project[]
│         loading: boolean
│         error: Error | null
│         createProject: (data: ProjectFormData) => Promise<void>
│         updateProject: (id: string, data: Partial<ProjectFormData>) => Promise<void>
│         deleteProject: (id: string) => Promise<void>
│         fetchProjects: () => Promise<void>
│       }
│       
│       interface UseProjectReturn {
│         project: Project | undefined
│         projectWithDetails: ReturnType<typeof selectors.selectProjectWithDetails>
│         updateProject: (data: Partial<ProjectFormData>) => Promise<void>
│         deleteProject: () => Promise<void>
│       }
│       
│       // Objective Hook Return Types
│       interface UseObjectivesReturn {
│         objectives: Objective[]
│         loading: boolean
│         error: Error | null
│         createObjective: (data: ObjectiveFormData) => Promise<void>
│         updateObjective: (id: string, data: Partial<ObjectiveFormData>) => Promise<void>
│         deleteObjective: (id: string) => Promise<void>
│         fetchObjectives: () => Promise<void>
│       }
│       
│       interface UseObjectiveReturn {
│         objective: Objective | undefined
│         objectiveWithDetails: ReturnType<typeof selectors.selectObjectiveWithDetails>
│         updateObjective: (data: Partial<ObjectiveFormData>) => Promise<void>
│         deleteObjective: () => Promise<void>
│       }
│       
│       // Task Hook Return Types
│       interface UseTasksReturn {
│         tasks: Task[]
│         loading: boolean
│         error: Error | null
│         createTask: (data: TaskFormData) => Promise<void>
│         updateTask: (id: string, data: Partial<TaskFormData>) => Promise<void>
│         deleteTask: (id: string) => Promise<void>
│         fetchTasks: () => Promise<void>
│       }
│       
│       interface UseTaskReturn {
│         task: Task | undefined
│         updateTask: (data: Partial<TaskFormData>) => Promise<void>
│         deleteTask: () => Promise<void>
│       }
│       
│       // TodoList Hook Return Types
│       interface UseTodoListsReturn {
│         todoLists: TodoList[]
│         loading: boolean
│         error: Error | null
│         createTodoList: (data: TodoListFormData) => Promise<void>
│         updateTodoList: (id: string, data: Partial<TodoListFormData>) => Promise<void>
│         deleteTodoList: (id: string) => Promise<void>
│         fetchTodoLists: () => Promise<void>
│       }
│       
│       interface UseTodoListReturn {
│         todoList: TodoList | undefined
│         todoListWithTasks: (TodoList & { tasks: Task[] }) | undefined
│         updateTodoList: (data: Partial<TodoListFormData>) => Promise<void>
│         deleteTodoList: () => Promise<void>
│       }
│       
│       // TimeEntry Hook Return Types
│       interface UseTimeEntriesReturn {
│         timeEntries: TimeEntry[]
│         loading: boolean
│         error: Error | null
│         createTimeEntry: (data: TimeEntryFormData) => Promise<void>
│         updateTimeEntry: (id: string, data: Partial<TimeEntryFormData>) => Promise<void>
│         deleteTimeEntry: (id: string) => Promise<void>
│         fetchTimeEntries: () => Promise<void>
│       }
│       
│       interface UseTimeEntryReturn {
│         timeEntry: TimeEntry | undefined
│         updateTimeEntry: (data: Partial<TimeEntryFormData>) => Promise<void>
│         deleteTimeEntry: () => Promise<void>
│       }
│       
│       // Project Hooks
│       export const useProjects = (): UseProjectsReturn => {
│         const projects = useStore(selectors.selectProjects)
│         const loading = useStore(selectors.selectProjectsLoading)
│         const error = useStore(selectors.selectProjectsError)
│         const createProject = useStore((state) => state.createProject)
│         const updateProject = useStore((state) => state.updateProject)
│         const deleteProject = useStore((state) => state.deleteProject)
│         const fetchProjects = useStore((state) => state.fetchProjects)
│       
│         return {
│           projects,
│           loading,
│           error,
│           createProject,
│           updateProject,
│           deleteProject,
│           fetchProjects
│         }
│       }
│       
│       export const useProject = (id: string): UseProjectReturn => {
│         const project = useStore((state) => selectors.selectProjectById(state, id))
│         const projectWithDetails = useStore((state) => selectors.selectProjectWithDetails(state, id))
│         const updateProject = useStore((state) => state.updateProject)
│         const deleteProject = useStore((state) => state.deleteProject)
│       
│         return {
│           project,
│           projectWithDetails,
│           updateProject: useCallback(
│             (data: Partial<ProjectFormData>) => updateProject(id, data),
│             [id, updateProject]
│           ),
│           deleteProject: useCallback(
│             () => deleteProject(id),
│             [id, deleteProject]
│           )
│         }
│       }
│       
│       // Objective Hooks
│       export const useObjectives = (): UseObjectivesReturn => {
│         const objectives = useStore(selectors.selectObjectives)
│         const loading = useStore(selectors.selectObjectivesLoading)
│         const error = useStore(selectors.selectObjectivesError)
│         const createObjective = useStore((state) => state.createObjective)
│         const updateObjective = useStore((state) => state.updateObjective)
│         const deleteObjective = useStore((state) => state.deleteObjective)
│         const fetchObjectives = useStore((state) => state.fetchObjectives)
│       
│         return {
│           objectives,
│           loading,
│           error,
│           createObjective,
│           updateObjective,
│           deleteObjective,
│           fetchObjectives
│         }
│       }
│       
│       export const useObjective = (id: string): UseObjectiveReturn => {
│         const objective = useStore((state) => selectors.selectObjectiveById(state, id))
│         const objectiveWithDetails = useStore((state) => selectors.selectObjectiveWithDetails(state, id))
│         const updateObjective = useStore((state) => state.updateObjective)
│         const deleteObjective = useStore((state) => state.deleteObjective)
│       
│         return {
│           objective,
│           objectiveWithDetails,
│           updateObjective: useCallback(
│             (data: Partial<ObjectiveFormData>) => updateObjective(id, data),
│             [id, updateObjective]
│           ),
│           deleteObjective: useCallback(
│             () => deleteObjective(id),
│             [id, deleteObjective]
│           )
│         }
│       }
│       
│       export const useTask = (id: string): UseTaskReturn => {
│         const task = useStore((state) => selectors.selectTaskById(state, id))
│         const updateTask = useStore((state) => state.updateTask)
│         const deleteTask = useStore((state) => state.deleteTask)
│       
│         return {
│           task,
│           updateTask: useCallback(
│             (data: Partial<TaskFormData>) => updateTask(id, data),
│             [id, updateTask]
│           ),
│           deleteTask: useCallback(
│             () => deleteTask(id),
│             [id, deleteTask]
│           )
│         }
│       }
│       
│       // TodoList Hooks
│       export const useTodoLists = (): UseTodoListsReturn => {
│         const todoLists = useStore(selectors.selectTodoLists)
│         const loading = useStore(selectors.selectTodoListsLoading)
│         const error = useStore(selectors.selectTodoListsError)
│         const createTodoList = useStore((state) => state.createTodoList)
│         const updateTodoList = useStore((state) => state.updateTodoList)
│         const deleteTodoList = useStore((state) => state.deleteTodoList)
│         const fetchTodoLists = useStore((state) => state.fetchTodoLists)
│       
│         return {
│           todoLists,
│           loading,
│           error,
│           createTodoList,
│           updateTodoList,
│           deleteTodoList,
│           fetchTodoLists
│         }
│       }
│       
│       export const useTodoList = (id: string): UseTodoListReturn => {
│         const todoList = useStore((state) => selectors.selectTodoListById(state, id))
│         const todoListWithTasks = useStore((state) => 
│           selectors.selectTodoListsWithTasks(state).find((list) => list.id === id)
│         )
│         const updateTodoList = useStore((state) => state.updateTodoList)
│         const deleteTodoList = useStore((state) => state.deleteTodoList)
│       
│         return {
│           todoList,
│           todoListWithTasks,
│           updateTodoList: useCallback(
│             (data: Partial<TodoListFormData>) => updateTodoList(id, data),
│             [id, updateTodoList]
│           ),
│           deleteTodoList: useCallback(
│             () => deleteTodoList(id),
│             [id, deleteTodoList]
│           )
│         }
│       }
│       
│       // TimeEntry Hooks
│       export const useTimeEntries = (): UseTimeEntriesReturn => {
│         const timeEntries = useStore(selectors.selectTimeEntries)
│         const loading = useStore(selectors.selectTimeEntriesLoading)
│         const error = useStore(selectors.selectTimeEntriesError)
│         const createTimeEntry = useStore((state) => state.createTimeEntry)
│         const updateTimeEntry = useStore((state) => state.updateTimeEntry)
│         const deleteTimeEntry = useStore((state) => state.deleteTimeEntry)
│         const fetchTimeEntries = useStore((state) => state.fetchTimeEntries)
│       
│         return {
│           timeEntries,
│           loading,
│           error,
│           createTimeEntry,
│           updateTimeEntry,
│           deleteTimeEntry,
│           fetchTimeEntries
│         }
│       }
│       
│       export const useTimeEntry = (id: string): UseTimeEntryReturn => {
│         const timeEntry = useStore((state) => selectors.selectTimeEntryById(state, id))
│         const updateTimeEntry = useStore((state) => state.updateTimeEntry)
│         const deleteTimeEntry = useStore((state) => state.deleteTimeEntry)
│       
│         return {
│           timeEntry,
│           updateTimeEntry: useCallback(
│             (data: Partial<TimeEntryFormData>) => updateTimeEntry(id, data),
│             [id, updateTimeEntry]
│           ),
│           deleteTimeEntry: useCallback(
│             () => deleteTimeEntry(id),
│             [id, deleteTimeEntry]
│           )
│         }
│       }
│       
│       // Global Hooks
│       interface UseStoreStatusReturn {
│         isLoading: boolean
│         hasError: boolean
│         clearErrors: () => void
│         refreshAll: () => Promise<void>
│       }
│       
│       export const useStoreStatus = (): UseStoreStatusReturn => {
│         const anyLoading = useStore(selectors.selectAnyLoading)
│         const anyError = useStore(selectors.selectAnyError)
│         const clearErrors = useStore((state) => state.clearErrors)
│         const refreshAll = useStore((state) => state.refreshAll)
│       
│         return {
│           isLoading: anyLoading,
│           hasError: !!anyError,
│           clearErrors,
│           refreshAll
│         }
│       }
├── index.ts
│       
│       // src/store/index.ts - Update store creation
│       import { create } from 'zustand';
│       import { devtools, persist } from 'zustand/middleware';
│       import { StoreState } from './types';
│       import { createProjectSlice } from './slices/project';
│       import { createTaskSlice } from './slices/tasks';
│       import { createObjectiveSlice } from './slices/objectives';
│       import { createTodoListSlice } from './slices/todoLists';
│       import { createTimeEntrySlice } from './slices/timeEntries';
│       import { createCardSlice } from './slices/card';
│       
│       const createStore = () => 
│         create<StoreState>()(
│           devtools(
│             persist(
│               (...a) => ({
│                 ...createCardSlice(...a),
│                 ...createProjectSlice(...a),
│                 ...createTaskSlice(...a),
│                 ...createObjectiveSlice(...a),
│                 ...createTodoListSlice(...a),
│                 ...createTimeEntrySlice(...a),
│               }),
│               {
│                 name: 'project-management-store',
│                 partialize: (state) => ({
│                   cardView: state.cardView,
│                   cardVariant: state.cardVariant,
│                   projects: state.projects,
│                   objectives: state.objectives,
│                   tasks: state.tasks,
│                   todoLists: state.todoLists,
│                   timeEntries: state.timeEntries,
│                 })
│               }
│             )
│           )
│         );
│       
│       export const useStore = createStore();
├── selectors/
│   ├── cards.ts
│   │       // src/store/selectors/cards.ts
│   │       import { createSelector } from '@reduxjs/toolkit';
│   │       import { StoreState } from '../types';
│   │       import type { Filterable } from '@/types';
│   │       
│   │       // Base selector
│   │       const selectCardStateBase = (state: StoreState) => ({
│   │         selectedCard: state.selectedCard,
│   │         cardView: state.cardView,
│   │         cardVariant: state.cardVariant,
│   │         filterStatus: state.filterStatus,
│   │         filterPriority: state.filterPriority,
│   │         sortBy: state.sortBy,
│   │         sortDirection: state.sortDirection,
│   │       });
│   │       
│   │       // Memoized selector (preferred)
│   │       export const selectCardState = createSelector(
│   │         [selectCardStateBase],
│   │         (cardState: ReturnType<typeof selectCardStateBase>) => cardState
│   │       );
│   │       
│   │       // Utility: Filter cards based on status and priority.
│   │       export const filterCards = <T extends Filterable>(
│   │         items: T[],
│   │         filterStatus: string | null,
│   │         filterPriority: string | null
│   │       ): T[] => {
│   │         return items.filter(item => {
│   │           const statusMatch = !filterStatus || item.status === filterStatus;
│   │           const priorityMatch = !filterPriority || (item as any).priority === filterPriority;
│   │           return statusMatch && priorityMatch;
│   │         });
│   │       };
│   │       
│   │       // Utility: Sort cards by a given property and direction.
│   │       export const sortCards = <T extends Filterable>(
│   │         items: T[],
│   │         sortBy: 'name' | 'date' | 'status' | 'priority' | null,
│   │         sortDirection: 'asc' | 'desc' = 'asc'
│   │       ): T[] => {
│   │         if (!sortBy) return items;
│   │       
│   │         const sorted = [...items].sort((a, b) => {
│   │           switch (sortBy) {
│   │             case 'name':
│   │               return (a.name || '').localeCompare(b.name || '');
│   │             case 'date':
│   │               return (
│   │                 new Date(a.createdAt || 0).getTime() - new Date(b.createdAt || 0).getTime()
│   │               );
│   │             case 'status':
│   │               return (a.status || '').localeCompare(b.status || '');
│   │             case 'priority':
│   │               return ((a as any).priority || '').localeCompare((b as any).priority || '');
│   │             default:
│   │               return 0;
│   │           }
│   │         });
│   │       
│   │         return sortDirection === 'asc' ? sorted : sorted.reverse();
│   │       };
│   │       
│   │       // Utility: Combine filtering and sorting.
│   │       export const selectFilteredAndSortedCards = <T extends Filterable>(
│   │         items: T[],
│   │         state: StoreState
│   │       ): T[] => {
│   │         const filtered = filterCards(items, state.filterStatus, state.filterPriority);
│   │         return sortCards(filtered, state.sortBy, state.sortDirection);
│   │       };
│   ├── index.ts
│   │       
│   │       // src/store/selectors/index.ts
│   │       export * from './projects';
│   │       export * from './tasks';
│   │       export * from './cards';
│   │       export * from './objectives';
│   │       export * from './timeEntries';
│   │       export * from './todoLists';
│   ├── objectives.ts
│   │       
│   │       // src/store/selectors/objectives.ts
│   │       import { StoreState } from '../types';
│   │       import { Objective } from '@/types';
│   │       
│   │       export const selectObjectives = (state: StoreState): Objective[] => state.objectives;
│   │       export const selectObjectivesLoading = (state: StoreState): boolean => state.objectivesLoading;
│   │       export const selectObjectivesError = (state: StoreState): Error | null => state.objectivesError;
│   ├── projects.ts
│   │       
│   │       // src/store/selectors/projects.ts
│   │       import { StoreState } from '../types';
│   │       import { Project } from '@/types';
│   │       
│   │       export const selectProjects = (state: StoreState): Project[] => state.projects;
│   │       export const selectProjectById = (state: StoreState, id: string): Project | undefined =>
│   │         state.projects.find((p) => p.id === id);
│   │       export const selectProjectsLoading = (state: StoreState): boolean => state.projectsLoading;
│   │       export const selectProjectsError = (state: StoreState): Error | null => state.projectsError;
│   ├── tasks.ts
│   │       
│   │       // src/store/selectors/tasks.ts
│   │       import { StoreState } from '../types';
│   │       import { Task } from '@/types';
│   │       
│   │       export const selectTasks = (state: StoreState): Task[] => state.tasks;
│   │       export const selectTaskById = (state: StoreState, id: string): Task | undefined =>
│   │         state.tasks.find((t) => t.id === id);
│   │       export const selectTasksLoading = (state: StoreState): boolean => state.tasksLoading;
│   │       export const selectTasksError = (state: StoreState): Error | null => state.tasksError;
│   │       export const selectTaskComplete = (state: StoreState, id: string): boolean =>
│   │         selectTaskById(state, id)?.status === 'done';
│   ├── timeEntries.ts
│   │       
│   │       // src/store/selectors/timeEntries.ts
│   │       import { StoreState } from '../types';
│   │       import { TimeEntry } from '@/types';
│   │       
│   │       export const selectTimeEntries = (state: StoreState): TimeEntry[] => state.timeEntries;
│   │       export const selectTimeEntriesLoading = (state: StoreState): boolean => state.timeEntriesLoading;
│   │       export const selectTimeEntriesError = (state: StoreState): Error | null => state.timeEntriesError;
│   └── todoLists.ts
│           
│           // src/store/selectors/todoLists.ts
│           import { StoreState } from '../types';
│           import { TodoList } from '@/types';
│           
│           export const selectTodoLists = (state: StoreState): TodoList[] => state.todoLists;
│           export const selectTodoListsLoading = (state: StoreState): boolean => state.todoListsLoading;
│           export const selectTodoListsError = (state: StoreState): Error | null => state.todoListsError;
├── selectors.ts
│       // src/store/selectors.ts
│       import { StoreState } from './index'
│       import {
│         Project,
│         Objective,
│         Task,
│         TodoList,
│         TimeEntry,
│         Status,
│         Priority
│       } from '@/types'
│       
│       // Project Selectors
│       export const selectProjects = (state: StoreState): Project[] => state.projects
│       
│       export const selectProjectById = (state: StoreState, id: string): Project | undefined => 
│         state.projects.find((p: Project) => p.id === id)
│       
│       export const selectActiveProjects = (state: StoreState): Project[] =>
│         state.projects.filter((p: Project) => p.status === 'active')
│       
│       export const selectProjectsLoading = (state: StoreState): boolean => state.projectsLoading
│       
│       export const selectProjectsError = (state: StoreState): Error | null => state.projectsError
│       
│       // Objective Selectors
│       export const selectObjectives = (state: StoreState): Objective[] => state.objectives
│       
│       export const selectObjectiveById = (state: StoreState, id: string): Objective | undefined =>
│         state.objectives.find((o: Objective) => o.id === id)
│       
│       export const selectObjectivesByProject = (state: StoreState, projectId: string): Objective[] =>
│         state.objectives.filter((o: Objective) => o.projectId === projectId)
│       
│       export const selectActiveObjectives = (state: StoreState): Objective[] =>
│         state.objectives.filter((o: Objective) => o.status === 'active')
│       
│       export const selectObjectivesLoading = (state: StoreState): boolean => state.objectivesLoading
│       
│       export const selectObjectivesError = (state: StoreState): Error | null => state.objectivesError
│       
│       // Task Selectors
│       export const selectTasks = (state: StoreState): Task[] => state.tasks
│       
│       export const selectTaskById = (state: StoreState, id: string): Task | undefined =>
│         state.tasks.find((t: Task) => t.id === id)
│       
│       export const selectTasksByProject = (state: StoreState, projectId: string): Task[] =>
│         state.tasks.filter((t: Task) => t.projectId === projectId)
│       
│       export const selectTasksByObjective = (state: StoreState, objectiveId: string): Task[] =>
│         state.tasks.filter((t: Task) => t.objectiveId === objectiveId)
│       
│       export const selectTasksByStatus = (state: StoreState, status: Status): Task[] =>
│         state.tasks.filter((t: Task) => t.status === status)
│       
│       export const selectTasksByPriority = (state: StoreState, priority: Priority): Task[] =>
│         state.tasks.filter((t: Task) => t.priority === priority)
│       
│       export const selectIncompleteTasks = (state: StoreState): Task[] =>
│         state.tasks.filter((t: Task) => t.status !== 'done')
│       
│       export const selectTasksLoading = (state: StoreState): boolean => state.tasksLoading
│       
│       export const selectTasksError = (state: StoreState): Error | null => state.tasksError
│       
│       // TodoList Selectors
│       export const selectTodoLists = (state: StoreState): TodoList[] => state.todoLists
│       
│       export const selectTodoListById = (state: StoreState, id: string): TodoList | undefined =>
│         state.todoLists.find((t: TodoList) => t.id === id)
│       
│       export interface TodoListWithTasks extends TodoList {
│         tasks: Task[]
│       }
│       
│       export const selectTodoListsByType = (state: StoreState, type: string): TodoList[] =>
│         state.todoLists.filter((t: TodoList) => t.type === type)
│       
│       export const selectTodoListsWithTasks = (state: StoreState): TodoListWithTasks[] =>
│         state.todoLists.map((list: TodoList) => ({
│           ...list,
│           tasks: state.tasks.filter((task: Task) => 
│             list.tasks?.some((t: Task) => t.id === task.id)
│           )
│         }))
│       
│       export const selectTodoListsLoading = (state: StoreState): boolean => state.todoListsLoading
│       
│       export const selectTodoListsError = (state: StoreState): Error | null => state.todoListsError
│       
│       // TimeEntry Selectors
│       export const selectTimeEntries = (state: StoreState): TimeEntry[] => state.timeEntries
│       
│       export const selectTimeEntryById = (state: StoreState, id: string): TimeEntry | undefined =>
│         state.timeEntries.find((t: TimeEntry) => t.id === id)
│       
│       export const selectTimeEntriesByTask = (state: StoreState, taskId: string): TimeEntry[] =>
│         state.timeEntries.filter((t: TimeEntry) => t.taskId === taskId)
│       
│       export const selectTimeEntriesByDate = (state: StoreState, date: Date): TimeEntry[] =>
│         state.timeEntries.filter((t: TimeEntry) => {
│           const entryDate = new Date(t.startTime)
│           return (
│             entryDate.getFullYear() === date.getFullYear() &&
│             entryDate.getMonth() === date.getMonth() &&
│             entryDate.getDate() === date.getDate()
│           )
│         })
│       
│       export const selectTimeEntriesByDateRange = (
│         state: StoreState, 
│         startDate: Date, 
│         endDate: Date
│       ): TimeEntry[] =>
│         state.timeEntries.filter((t: TimeEntry) => {
│           const entryDate = new Date(t.startTime)
│           return entryDate >= startDate && entryDate <= endDate
│         })
│       
│       export const selectTotalTimeSpent = (state: StoreState): number =>
│         state.timeEntries.reduce((total: number, entry: TimeEntry) => {
│           if (!entry.duration) return total
│           return total + entry.duration
│         }, 0)
│       
│       export const selectTimeEntriesLoading = (state: StoreState): boolean => 
│         state.timeEntriesLoading
│       
│       export const selectTimeEntriesError = (state: StoreState): Error | null => 
│         state.timeEntriesError
│       
│       // Combined Selectors
│       interface ProjectWithDetails extends Project {
│         objectives: Objective[]
│         tasks: Task[]
│         timeSpent: number
│       }
│       
│       interface ObjectiveWithProgress extends Objective {
│         tasks: Task[]
│         progress: {
│           total: number
│           completed: number
│           inProgress: number
│         }
│       }
│       
│       export const selectProjectWithDetails = (
│         state: StoreState, 
│         projectId: string
│       ): ProjectWithDetails | null => {
│         const project = selectProjectById(state, projectId)
│         if (!project) return null
│       
│         return {
│           ...project,
│           objectives: selectObjectivesByProject(state, projectId),
│           tasks: selectTasksByProject(state, projectId),
│           timeSpent: selectTimeEntriesByDateRange(
│             state,
│             project.startDate || new Date(0),
│             project.dueDate || new Date()
│           ).reduce((total: number, entry: TimeEntry) => total + (entry.duration || 0), 0)
│         }
│       }
│       
│       export const selectObjectiveWithDetails = (
│         state: StoreState, 
│         objectiveId: string
│       ): ObjectiveWithProgress | null => {
│         const objective = selectObjectiveById(state, objectiveId)
│         if (!objective) return null
│       
│         const tasks = selectTasksByObjective(state, objectiveId)
│         return {
│           ...objective,
│           tasks,
│           progress: {
│             total: tasks.length,
│             completed: tasks.filter((t: Task) => t.status === 'done').length,
│             inProgress: tasks.filter((t: Task) => t.status === 'in-progress').length
│           }
│         }
│       }
│       
│       // Loading States
│       export const selectAnyLoading = (state: StoreState): boolean =>
│         state.projectsLoading ||
│         state.objectivesLoading ||
│         state.tasksLoading ||
│         state.todoListsLoading ||
│         state.timeEntriesLoading
│       
│       // Error States
│       export const selectAnyError = (state: StoreState): Error | null =>
│         state.projectsError ||
│         state.objectivesError ||
│         state.tasksError ||
│         state.todoListsError ||
│         state.timeEntriesError
├── slices/
│   ├── card.ts
│   │       
│   │       // src/store/slices/card.ts
│   │       import { StateCreator } from 'zustand';
│   │       
│   │       export type CardViewType = 'grid' | 'list';
│   │       export type CardVariantType = 'default' | 'compact' | 'detailed';
│   │       export type CardSortType = 'name' | 'date' | 'status' | 'priority' | null;
│   │       export type SortDirectionType = 'asc' | 'desc';
│   │       
│   │       export interface SelectedCard {
│   │         type: 'project' | 'task' | 'objective' | 'todoList';
│   │         id: string;
│   │       }
│   │       
│   │       export interface CardState {
│   │         selectedCard: SelectedCard | null;
│   │         cardView: CardViewType;
│   │         cardVariant: CardVariantType;
│   │         filterStatus: string | null;
│   │         filterPriority: string | null;
│   │         sortBy: CardSortType;
│   │         sortDirection: SortDirectionType;
│   │       }
│   │       
│   │       export interface CardSlice extends CardState {
│   │         setSelectedCard: (card: SelectedCard | null) => void;
│   │         setCardView: (view: CardViewType) => void;
│   │         setCardVariant: (variant: CardVariantType) => void;
│   │         setFilterStatus: (status: string | null) => void;
│   │         setFilterPriority: (priority: string | null) => void;
│   │         setSortBy: (sortBy: CardSortType) => void;
│   │         toggleSortDirection: () => void;
│   │       }
│   │       
│   │       export const createCardSlice: StateCreator<CardSlice> = (set) => ({
│   │         selectedCard: null,
│   │         cardView: 'grid',
│   │         cardVariant: 'default',
│   │         filterStatus: null,
│   │         filterPriority: null,
│   │         sortBy: null,
│   │         sortDirection: 'asc',
│   │       
│   │         setSelectedCard: (card) => set({ selectedCard: card }),
│   │         setCardView: (view) => set({ cardView: view }),
│   │         setCardVariant: (variant) => set({ cardVariant: variant }),
│   │         setFilterStatus: (status) => set({ filterStatus: status }),
│   │         setFilterPriority: (priority) => set({ filterPriority: priority }),
│   │         setSortBy: (sortBy) => set({ sortBy }),
│   │         toggleSortDirection: () => 
│   │           set((state) => ({ 
│   │             sortDirection: state.sortDirection === 'asc' ? 'desc' : 'asc' 
│   │           })),
│   │       });
│   ├── objectives.ts
│   │       
│   │       // src/store/slices/objectives.ts
│   │       import { StateCreator } from 'zustand';
│   │       import { Objective, ObjectiveFormData } from '@/types';
│   │       import { objectivesApi } from '@/lib/api/objectives';
│   │       
│   │       export interface ObjectiveSlice {
│   │         objectives: Objective[];
│   │         objectivesLoading: boolean;
│   │         objectivesError: Error | null;
│   │         fetchObjectives: () => Promise<void>;
│   │         createObjective: (data: ObjectiveFormData) => Promise<void>;
│   │         updateObjective: (id: string, data: Partial<ObjectiveFormData>) => Promise<void>;
│   │         deleteObjective: (id: string) => Promise<void>;
│   │       }
│   │       
│   │       export const createObjectiveSlice: StateCreator<ObjectiveSlice> = (set) => ({
│   │         objectives: [],
│   │         objectivesLoading: false,
│   │         objectivesError: null,
│   │         fetchObjectives: async () => {
│   │           set({ objectivesLoading: true });
│   │           try {
│   │             const objectives = await objectivesApi.getObjectives();
│   │             set({ objectives, objectivesError: null });
│   │           } catch (error) {
│   │             set({ objectivesError: error as Error });
│   │           } finally {
│   │             set({ objectivesLoading: false });
│   │           }
│   │         },
│   │         createObjective: async (data) => {
│   │           set({ objectivesLoading: true });
│   │           try {
│   │             const newObjective = await objectivesApi.createObjective(data);
│   │             set((state) => ({
│   │               objectives: [...state.objectives, newObjective],
│   │               objectivesError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ objectivesError: error as Error });
│   │           } finally {
│   │             set({ objectivesLoading: false });
│   │           }
│   │         },
│   │         updateObjective: async (id, data) => {
│   │           set({ objectivesLoading: true });
│   │           try {
│   │             const updatedObjective = await objectivesApi.updateObjective(id, data);
│   │             set((state) => ({
│   │               objectives: state.objectives.map((o) => o.id === id ? updatedObjective : o),
│   │               objectivesError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ objectivesError: error as Error });
│   │           } finally {
│   │             set({ objectivesLoading: false });
│   │           }
│   │         },
│   │         deleteObjective: async (id) => {
│   │           set({ objectivesLoading: true });
│   │           try {
│   │             await objectivesApi.deleteObjective(id);
│   │             set((state) => ({
│   │               objectives: state.objectives.filter((o) => o.id !== id),
│   │               objectivesError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ objectivesError: error as Error });
│   │           } finally {
│   │             set({ objectivesLoading: false });
│   │           }
│   │         },
│   │       });
│   ├── project.ts
│   │       // src/store/slices/projects.ts
│   │       import { StateCreator } from 'zustand';
│   │       import { Project, ProjectFormData } from '@/types';
│   │       import { projectsApi } from '@/lib/api/projects';
│   │       
│   │       export interface ProjectSlice {
│   │         projects: Project[];
│   │         projectsLoading: boolean;
│   │         projectsError: Error | null;
│   │         fetchProjects: () => Promise<void>;
│   │         createProject: (data: ProjectFormData) => Promise<void>;
│   │         updateProject: (id: string, data: Partial<ProjectFormData>) => Promise<void>;
│   │         deleteProject: (id: string) => Promise<void>;
│   │       }
│   │       
│   │       export const createProjectSlice: StateCreator<ProjectSlice> = (set) => ({
│   │         projects: [],
│   │         projectsLoading: false,
│   │         projectsError: null,
│   │         fetchProjects: async () => {
│   │           set({ projectsLoading: true });
│   │           try {
│   │             const projects = await projectsApi.getProjects();
│   │             set({ projects, projectsError: null });
│   │           } catch (error) {
│   │             set({ projectsError: error as Error });
│   │           } finally {
│   │             set({ projectsLoading: false });
│   │           }
│   │         },
│   │         createProject: async (data) => {
│   │           set({ projectsLoading: true });
│   │           try {
│   │             const newProject = await projectsApi.createProject(data);
│   │             set((state) => ({
│   │               projects: [...state.projects, newProject],
│   │               projectsError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ projectsError: error as Error });
│   │           } finally {
│   │             set({ projectsLoading: false });
│   │           }
│   │         },
│   │         updateProject: async (id, data) => {
│   │           set({ projectsLoading: true });
│   │           try {
│   │             const updatedProject = await projectsApi.updateProject(id, data);
│   │             set((state) => ({
│   │               projects: state.projects.map((p) => p.id === id ? updatedProject : p),
│   │               projectsError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ projectsError: error as Error });
│   │           } finally {
│   │             set({ projectsLoading: false });
│   │           }
│   │         },
│   │         deleteProject: async (id) => {
│   │           set({ projectsLoading: true });
│   │           try {
│   │             await projectsApi.deleteProject(id);
│   │             set((state) => ({
│   │               projects: state.projects.filter((p) => p.id !== id),
│   │               projectsError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ projectsError: error as Error });
│   │           } finally {
│   │             set({ projectsLoading: false });
│   │           }
│   │         },
│   │       });
│   ├── tasks.ts
│   │       // src/store/slices/tasks.ts
│   │       import { StateCreator } from 'zustand';
│   │       import type { Task, TaskFormData } from '@/types';
│   │       import { tasksApi } from '@/lib/api/tasks';
│   │       
│   │       export interface TaskSlice {
│   │         tasks: Task[];
│   │         tasksLoading: boolean;
│   │         tasksError: Error | null;
│   │         fetchTasks: () => Promise<void>;
│   │         createTask: (data: TaskFormData) => Promise<void>;
│   │         updateTask: (id: string, data: Partial<TaskFormData>) => Promise<void>;
│   │         deleteTask: (id: string) => Promise<void>;
│   │         markTaskComplete: (id: string) => Promise<void>;
│   │       }
│   │       
│   │       export const createTaskSlice: StateCreator<TaskSlice> = (set) => ({
│   │         tasks: [],
│   │         tasksLoading: false,
│   │         tasksError: null,
│   │         fetchTasks: async () => {
│   │           set({ tasksLoading: true });
│   │           try {
│   │             const tasks = await tasksApi.getTasks();
│   │             set({ tasks, tasksError: null });
│   │           } catch (error) {
│   │             set({ tasksError: error as Error });
│   │           } finally {
│   │             set({ tasksLoading: false });
│   │           }
│   │         },
│   │         createTask: async (data) => {
│   │           set({ tasksLoading: true });
│   │           try {
│   │             const newTask = await tasksApi.createTask(data);
│   │             set((state) => ({
│   │               tasks: [...state.tasks, newTask],
│   │               tasksError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ tasksError: error as Error });
│   │           } finally {
│   │             set({ tasksLoading: false });
│   │           }
│   │         },
│   │         updateTask: async (id, data) => {
│   │           set({ tasksLoading: true });
│   │           try {
│   │             const updatedTask = await tasksApi.updateTask(id, data);
│   │             set((state) => ({
│   │               tasks: state.tasks.map((t) => t.id === id ? updatedTask : t),
│   │               tasksError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ tasksError: error as Error });
│   │           } finally {
│   │             set({ tasksLoading: false });
│   │           }
│   │         },
│   │         deleteTask: async (id) => {
│   │           set({ tasksLoading: true });
│   │           try {
│   │             await tasksApi.deleteTask(id);
│   │             set((state) => ({
│   │               tasks: state.tasks.filter((t) => t.id !== id),
│   │               tasksError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ tasksError: error as Error });
│   │           } finally {
│   │             set({ tasksLoading: false });
│   │           }
│   │         },
│   │         markTaskComplete: async (id) => {
│   │           set({ tasksLoading: true });
│   │           try {
│   │             const updatedTask = await tasksApi.markComplete(id);
│   │             set((state) => ({
│   │               tasks: state.tasks.map((t) => t.id === id ? updatedTask : t),
│   │               tasksError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ tasksError: error as Error });
│   │             throw error;
│   │           } finally {
│   │             set({ tasksLoading: false });
│   │           }
│   │         },
│   │       });
│   ├── timeEntries.ts
│   │       
│   │       // src/store/slices/timeEntries.ts
│   │       import { StateCreator } from 'zustand';
│   │       import { TimeEntry, TimeEntryFormData } from '@/types';
│   │       import { timeEntriesApi } from '@/lib/api/timeEntries';
│   │       
│   │       export interface TimeEntrySlice {
│   │         timeEntries: TimeEntry[];
│   │         timeEntriesLoading: boolean;
│   │         timeEntriesError: Error | null;
│   │         fetchTimeEntries: () => Promise<void>;
│   │         createTimeEntry: (data: TimeEntryFormData) => Promise<void>;
│   │         updateTimeEntry: (id: string, data: Partial<TimeEntryFormData>) => Promise<void>;
│   │         deleteTimeEntry: (id: string) => Promise<void>;
│   │       }
│   │       
│   │       export const createTimeEntrySlice: StateCreator<TimeEntrySlice> = (set) => ({
│   │         timeEntries: [],
│   │         timeEntriesLoading: false,
│   │         timeEntriesError: null,
│   │         fetchTimeEntries: async () => {
│   │           set({ timeEntriesLoading: true });
│   │           try {
│   │             const timeEntries = await timeEntriesApi.getTimeEntries();
│   │             set({ timeEntries, timeEntriesError: null });
│   │           } catch (error) {
│   │             set({ timeEntriesError: error as Error });
│   │           } finally {
│   │             set({ timeEntriesLoading: false });
│   │           }
│   │         },
│   │         createTimeEntry: async (data) => {
│   │           set({ timeEntriesLoading: true });
│   │           try {
│   │             const newTimeEntry = await timeEntriesApi.createTimeEntry(data);
│   │             set((state) => ({
│   │               timeEntries: [...state.timeEntries, newTimeEntry],
│   │               timeEntriesError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ timeEntriesError: error as Error });
│   │           } finally {
│   │             set({ timeEntriesLoading: false });
│   │           }
│   │         },
│   │         updateTimeEntry: async (id, data) => {
│   │           set({ timeEntriesLoading: true });
│   │           try {
│   │             const updatedTimeEntry = await timeEntriesApi.updateTimeEntry(id, data);
│   │             set((state) => ({
│   │               timeEntries: state.timeEntries.map((t) => t.id === id ? updatedTimeEntry : t),
│   │               timeEntriesError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ timeEntriesError: error as Error });
│   │           } finally {
│   │             set({ timeEntriesLoading: false });
│   │           }
│   │         },
│   │         deleteTimeEntry: async (id) => {
│   │           set({ timeEntriesLoading: true });
│   │           try {
│   │             await timeEntriesApi.deleteTimeEntry(id);
│   │             set((state) => ({
│   │               timeEntries: state.timeEntries.filter((t) => t.id !== id),
│   │               timeEntriesError: null
│   │             }));
│   │           } catch (error) {
│   │             set({ timeEntriesError: error as Error });
│   │           } finally {
│   │             set({ timeEntriesLoading: false });
│   │           }
│   │         },
│   │       });
│   └── todoLists.ts
│           // src/store/slices/todoLists.ts
│           import { StateCreator } from 'zustand';
│           import { TodoList, TodoListFormData } from '@/types';
│           import { todoListsApi } from '@/lib/api/todoLists';
│           
│           export interface TodoListSlice {
│             todoLists: TodoList[];
│             todoListsLoading: boolean;
│             todoListsError: Error | null;
│             fetchTodoLists: () => Promise<void>;
│             createTodoList: (data: TodoListFormData) => Promise<void>;
│             updateTodoList: (id: string, data: Partial<TodoListFormData>) => Promise<void>;
│             deleteTodoList: (id: string) => Promise<void>;
│           }
│           
│           export const createTodoListSlice: StateCreator<TodoListSlice> = (set) => ({
│             todoLists: [],
│             todoListsLoading: false,
│             todoListsError: null,
│             fetchTodoLists: async () => {
│               set({ todoListsLoading: true });
│               try {
│                 const todoLists = await todoListsApi.getTodoLists();
│                 set({ todoLists, todoListsError: null });
│               } catch (error) {
│                 set({ todoListsError: error as Error });
│               } finally {
│                 set({ todoListsLoading: false });
│               }
│             },
│             createTodoList: async (data) => {
│               set({ todoListsLoading: true });
│               try {
│                 const newTodoList = await todoListsApi.createTodoList(data);
│                 set((state) => ({
│                   todoLists: [...state.todoLists, newTodoList],
│                   todoListsError: null
│                 }));
│               } catch (error) {
│                 set({ todoListsError: error as Error });
│               } finally {
│                 set({ todoListsLoading: false });
│               }
│             },
│             updateTodoList: async (id, data) => {
│               set({ todoListsLoading: true });
│               try {
│                 const updatedTodoList = await todoListsApi.updateTodoList(id, data);
│                 set((state) => ({
│                   todoLists: state.todoLists.map((t) => t.id === id ? updatedTodoList : t),
│                   todoListsError: null
│                 }));
│               } catch (error) {
│                 set({ todoListsError: error as Error });
│               } finally {
│                 set({ todoListsLoading: false });
│               }
│             },
│             deleteTodoList: async (id) => {
│               set({ todoListsLoading: true });
│               try {
│                 await todoListsApi.deleteTodoList(id);
│                 set((state) => ({
│                   todoLists: state.todoLists.filter((t) => t.id !== id),
│                   todoListsError: null
│                 }));
│               } catch (error) {
│                 set({ todoListsError: error as Error });
│               } finally {
│                 set({ todoListsLoading: false });
│               }
│             },
│           });
└── types.ts
        // src/store/types.ts
        import { CardSlice } from './slices/card';
        import { ProjectSlice } from './slices/project';
        import { TaskSlice } from './slices/tasks';
        import { ObjectiveSlice } from './slices/objectives';
        import { TodoListSlice } from './slices/todoLists';
        import { TimeEntrySlice } from './slices/timeEntries';
        
        export type StoreState = 
          & CardSlice 
          & ProjectSlice 
          & TaskSlice 
          & ObjectiveSlice 
          & TodoListSlice 
          & TimeEntrySlice;
