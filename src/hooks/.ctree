hooks/
├── forms/
│   ├── index.ts
│   │       export * from './useFields';
│   │       export * from './useForm';
│   ├── useFields.ts
│   │       // src/hooks/forms/useField.ts
│   │       import { useCallback } from 'react';
│   │       import type { FieldConfig, FieldValue } from '@/types/forms/fields';
│   │       
│   │       interface UseFieldProps<T extends FieldConfig> {
│   │         field: T;
│   │         value: FieldValue<T>;
│   │         onChange: (name: string, value: any) => void;
│   │         onBlur?: (name: string) => void;
│   │         validate?: (value: any) => string | undefined;
│   │       }
│   │       
│   │       interface UseFieldReturn<T extends FieldConfig> {
│   │         inputProps: {
│   │           name: string;
│   │           value: FieldValue<T>;
│   │           onChange: (event: React.ChangeEvent<any>) => void;
│   │           onBlur: (event: React.FocusEvent<any>) => void;
│   │           required?: boolean;
│   │           disabled?: boolean;
│   │           placeholder?: string;
│   │           className?: string;
│   │         };
│   │         handleChange: (value: FieldValue<T>) => void;
│   │         handleBlur: () => void;
│   │       }
│   │       
│   │       export function useField<T extends FieldConfig>({
│   │         field,
│   │         value,
│   │         onChange,
│   │         onBlur,
│   │         validate,
│   │       }: UseFieldProps<T>): UseFieldReturn<T> {
│   │         const handleChange = useCallback((newValue: FieldValue<T>) => {
│   │           onChange(field.name, newValue);
│   │         }, [field.name, onChange]);
│   │       
│   │         const handleChangeEvent = useCallback((event: React.ChangeEvent<any>) => {
│   │           const value = event.target.value;
│   │           handleChange(value as FieldValue<T>);
│   │         }, [handleChange]);
│   │       
│   │         const handleBlur = useCallback(() => {
│   │           if (onBlur) {
│   │             onBlur(field.name);
│   │           }
│   │         }, [field.name, onBlur]);
│   │       
│   │         return {
│   │           inputProps: {
│   │             name: field.name,
│   │             value: value ?? '',
│   │             onChange: handleChangeEvent,
│   │             onBlur: handleBlur,
│   │             required: field.required,
│   │             disabled: field.disabled,
│   │             placeholder: field.placeholder,
│   │             className: field.className,
│   │           },
│   │           handleChange,
│   │           handleBlur,
│   │         };
│   │       }
│   └── useForm.ts
│           // src/hooks/forms/useForm.ts
│           import { useState, useCallback } from 'react';
│           import type { FieldValue, FieldConfig } from '@/types/forms/fields';
│           
│           interface FormState<T> {
│             values: T;
│             errors: Record<string, string>;
│             touched: Record<keyof T, boolean>;
│             isSubmitting: boolean;
│             isDirty: boolean;
│           }
│           
│           interface UseFormOptions<T> {
│             initialValues: T;
│             onSubmit: (values: T) => Promise<void>;
│             validate?: (values: T) => Record<string, string>;
│             validateOnChange?: boolean;
│             validateOnBlur?: boolean;
│           }
│           
│           interface UseFormReturn<T> {
│             // Form state
│             values: T;
│             errors: Record<string, string>;
│             touched: Record<keyof T, boolean>;
│             isSubmitting: boolean;
│             isDirty: boolean;
│             isValid: boolean;
│           
│             // Event handlers
│             handleChange: (name: string, value: any) => void;
│             handleBlur: (name: string) => void;
│             handleSubmit: (e: React.FormEvent) => Promise<void>;
│           
│             // Field helpers
│             setFieldValue: (field: keyof T, value: any) => void;
│             setFieldError: (field: keyof T, error: string) => void;
│             setFieldTouched: (field: keyof T, isTouched?: boolean) => void;
│           
│             // Form helpers
│             resetForm: () => void;
│             validateForm: () => Promise<Record<string, string>>;
│             validateField: (field: keyof T) => Promise<string | undefined>;
│             setValues: (values: T) => void;
│             setErrors: (errors: Record<string, string>) => void;
│             setTouched: (touched: Record<keyof T, boolean>) => void;
│           }
│           
│           export function useForm<T extends Record<string, any>>({
│             initialValues,
│             onSubmit,
│             validate,
│             validateOnChange = false,
│             validateOnBlur = true,
│           }: UseFormOptions<T>): UseFormReturn<T> {
│             const [formState, setFormState] = useState<FormState<T>>({
│               values: initialValues,
│               errors: {},
│               touched: {} as Record<keyof T, boolean>,
│               isSubmitting: false,
│               isDirty: false,
│             });
│           
│             const setValues = useCallback((values: T) => {
│               setFormState(prev => ({
│                 ...prev,
│                 values,
│                 isDirty: true,
│               }));
│             }, []);
│           
│             const setErrors = useCallback((errors: Record<string, string>) => {
│               setFormState(prev => ({
│                 ...prev,
│                 errors,
│               }));
│             }, []);
│           
│             const setTouched = useCallback((touched: Record<keyof T, boolean>) => {
│               setFormState(prev => ({
│                 ...prev,
│                 touched,
│               }));
│             }, []);
│           
│             const validateField = useCallback(async (field: keyof T): Promise<string | undefined> => {
│               if (!validate) return;
│               
│               const errors = await validate(formState.values);
│               return errors[field as string];
│             }, [validate, formState.values]);
│           
│             const validateForm = useCallback(async (): Promise<Record<string, string>> => {
│               if (!validate) return {};
│               
│               const errors = await validate(formState.values);
│               setErrors(errors);
│               return errors;
│             }, [validate, formState.values, setErrors]);
│           
│             const setFieldValue = useCallback((field: keyof T, value: any) => {
│               setFormState(prev => ({
│                 ...prev,
│                 values: { ...prev.values, [field]: value },
│                 isDirty: true,
│               }));
│           
│               if (validateOnChange) {
│                 validateField(field);
│               }
│             }, [validateOnChange, validateField]);
│           
│             const setFieldError = useCallback((field: keyof T, error: string) => {
│               setFormState(prev => ({
│                 ...prev,
│                 errors: { ...prev.errors, [field]: error },
│               }));
│             }, []);
│           
│             const setFieldTouched = useCallback((field: keyof T, isTouched = true) => {
│               setFormState(prev => ({
│                 ...prev,
│                 touched: { ...prev.touched, [field]: isTouched },
│               }));
│             }, []);
│           
│             const handleChange = useCallback((name: string, value: any) => {
│               setFieldValue(name as keyof T, value);
│             }, [setFieldValue]);
│           
│             const handleBlur = useCallback((name: string) => {
│               setFieldTouched(name as keyof T, true);
│               
│               if (validateOnBlur) {
│                 validateField(name as keyof T);
│               }
│             }, [validateOnBlur, validateField, setFieldTouched]);
│           
│             const resetForm = useCallback(() => {
│               setFormState({
│                 values: initialValues,
│                 errors: {},
│                 touched: {} as Record<keyof T, boolean>,
│                 isSubmitting: false,
│                 isDirty: false,
│               });
│             }, [initialValues]);
│           
│             const handleSubmit = useCallback(async (e: React.FormEvent) => {
│               e.preventDefault();
│               setFormState(prev => ({ ...prev, isSubmitting: true }));
│           
│               try {
│                 // Validate all fields
│                 const errors = await validateForm();
│                 
│                 if (Object.keys(errors).length === 0) {
│                   await onSubmit(formState.values);
│                   resetForm();
│                 }
│               } catch (error) {
│                 setFieldError('submit' as keyof T, error instanceof Error ? error.message : 'An error occurred');
│               } finally {
│                 setFormState(prev => ({ ...prev, isSubmitting: false }));
│               }
│             }, [formState.values, onSubmit, validateForm, resetForm, setFieldError]);
│           
│             const isValid = Object.keys(formState.errors).length === 0;
│           
│             return {
│               // Form state
│               ...formState,
│               isValid,
│           
│               // Event handlers
│               handleChange,
│               handleBlur,
│               handleSubmit,
│           
│               // Field helpers
│               setFieldValue,
│               setFieldError,
│               setFieldTouched,
│           
│               // Form helpers
│               resetForm,
│               validateForm,
│               validateField,
│               setValues,
│               setErrors,
│               setTouched,
│             };
│           }
├── index.ts
│       // src/hooks/index.ts
│       export * from './useProjects';
│       export * from './useObjectives';
│       export * from './useTasks';
│       export * from './useTodoLists';
│       export * from './useTimeEntries';
│       export * from './forms';
├── useObjectives.ts
│       // src/hooks/useObjectives.ts
│       import { useState, useEffect, useCallback } from 'react';
│       import type { Objective, ObjectiveFormData } from '@/types';
│       import { objectivesApi } from '@/lib/api/objectives';
│       
│       interface UseObjectivesReturn {
│         objectives: Objective[];
│         loading: boolean;
│         error: Error | null;
│         fetchObjectives: () => Promise<void>;
│         createObjective: (data: ObjectiveFormData) => Promise<void>;
│         refresh: () => Promise<void>;
│       }
│       
│       export const useObjectives = (): UseObjectivesReturn => {
│         const [objectives, setObjectives] = useState<Objective[]>([]);
│         const [loading, setLoading] = useState<boolean>(true);
│         const [error, setError] = useState<Error | null>(null);
│       
│         const fetchObjectives = useCallback(async () => {
│           setLoading(true);
│           setError(null);
│           try {
│             const fetchedObjectives = await objectivesApi.getObjectives();
│             setObjectives(fetchedObjectives);
│           } catch (err: any) {
│             setError(err);
│           } finally {
│             setLoading(false);
│           }
│         }, []);
│       
│         const createObjective = useCallback(async (data: ObjectiveFormData) => {
│           setLoading(true);
│           try {
│             const newObjective = await objectivesApi.createObjective(data);
│             setObjectives(prev => [...prev, newObjective]);
│             setError(null);
│           } catch (err) {
│             setError(err as Error);
│           } finally {
│             setLoading(false);
│           }
│         }, []);
│       
│         const refresh = useCallback(async () => {
│           await fetchObjectives();
│         }, [fetchObjectives]);
│       
│         useEffect(() => {
│           fetchObjectives();
│         }, [fetchObjectives]);
│       
│         return { objectives, loading, error, fetchObjectives, createObjective, refresh };
│       };
├── useProjects.ts
│       // src/hooks/useProjects.ts
│       import { useState, useEffect, useCallback } from 'react';
│       import type { Project, ProjectFormData } from '@/types';
│       import { projectsApi } from '@/lib/api/projects';
│       
│       interface UseProjectsReturn {
│         projects: Project[];
│         loading: boolean;
│         error: Error | null;
│         fetchProjects: () => Promise<void>;
│         createProject: (data: ProjectFormData) => Promise<void>;
│         refresh: () => Promise<void>;
│       }
│       
│       export function useProjects(): UseProjectsReturn {
│         const [projects, setProjects] = useState<Project[]>([]);
│         const [loading, setLoading] = useState<boolean>(false);
│         const [error, setError] = useState<Error | null>(null);
│       
│         const fetchProjects = useCallback(async () => {
│           setLoading(true);
│           try {
│             const data = await projectsApi.getProjects();
│             setProjects(data);
│             setError(null);
│           } catch (err) {
│             setError(err as Error);
│           } finally {
│             setLoading(false);
│           }
│         }, []);
│       
│         const createProject = useCallback(async (data: ProjectFormData) => {
│           setLoading(true);
│           try {
│             const newProject = await projectsApi.createProject(data);
│             setProjects(prev => [...prev, newProject]);
│             setError(null);
│           } catch (err) {
│             setError(err as Error);
│           } finally {
│             setLoading(false);
│           }
│         }, []);
│       
│         const refresh = useCallback(async () => {
│           await fetchProjects();
│         }, [fetchProjects]);
│       
│         useEffect(() => {
│           fetchProjects();
│         }, [fetchProjects]);
│       
│         return { projects, loading, error, fetchProjects, createProject, refresh };
│       }
├── useTasks.ts
│       // src/hooks/useTasks.ts
│       import { useState, useEffect, useCallback } from 'react';
│       import type { Task, TaskFormData } from '@/types';
│       import { tasksApi } from '@/lib/api/tasks';
│       
│       interface UseTasksReturn {
│         tasks: Task[];
│         loading: boolean;
│         error: Error | null;
│         fetchTasks: () => Promise<void>;
│         createTask: (data: TaskFormData) => Promise<void>;
│         refresh: () => Promise<void>;
│       }
│       
│       export const useTasks = (): UseTasksReturn => {
│         const [tasks, setTasks] = useState<Task[]>([]);
│         const [loading, setLoading] = useState<boolean>(true);
│         const [error, setError] = useState<Error | null>(null);
│       
│         const fetchTasks = useCallback(async () => {
│           setLoading(true);
│           setError(null);
│           try {
│             const fetchedTasks = await tasksApi.getTasks();
│             setTasks(fetchedTasks);
│           } catch (err: any) {
│             setError(err);
│           } finally {
│             setLoading(false);
│           }
│         }, []);
│       
│         const createTask = useCallback(async (data: TaskFormData) => {
│           setLoading(true);
│           try {
│             const newTask = await tasksApi.createTask(data);
│             setTasks(prev => [...prev, newTask]);
│             setError(null);
│           } catch (err) {
│             setError(err as Error);
│           } finally {
│             setLoading(false);
│           }
│         }, []);
│       
│         const refresh = useCallback(async () => {
│           await fetchTasks();
│         }, [fetchTasks]);
│       
│         useEffect(() => {
│           fetchTasks();
│         }, [fetchTasks]);
│       
│         return { tasks, loading, error, fetchTasks, createTask, refresh };
│       };
├── useTimeEntries.ts
│       // src/hooks/useTimeEntries.ts
│       import { useState, useEffect, useCallback } from 'react';
│       import type { TimeEntry } from '@/types';
│       import { timeEntriesApi } from '@/lib/api/timeEntries';
│       
│       interface TimeEntryStats {
│         totalHours: number;
│         entriesCount: number;
│         averageEntryDuration: number;
│       }
│       
│       interface UseTimeEntriesReturn {
│         timeEntries: TimeEntry[];
│         stats: TimeEntryStats;
│         loading: boolean;
│         error: Error | null;
│         fetchTimeEntries: () => Promise<void>; // Added fetchTimeEntries
│       }
│       
│       export const useTimeEntries = (): UseTimeEntriesReturn => {
│         const [timeEntries, setTimeEntries] = useState<TimeEntry[]>([]);
│         const [stats, setStats] = useState<TimeEntryStats>({
│           totalHours: 0,
│           entriesCount: 0,
│           averageEntryDuration: 0,
│         });
│         const [loading, setLoading] = useState<boolean>(true);
│         const [error, setError] = useState<Error | null>(null);
│       
│         const fetchTimeEntries = useCallback(async () => {
│           setLoading(true);
│           setError(null);
│           try {
│             const fetchedTimeEntries = await timeEntriesApi.getTimeEntries();
│             setTimeEntries(fetchedTimeEntries);
│       
│             // Calculate stats
│             const totalDuration = fetchedTimeEntries.reduce((acc, entry) => acc + (entry.duration || 0), 0);
│             const entriesCount = fetchedTimeEntries.length;
│             const averageEntryDuration = entriesCount > 0 ? totalDuration / entriesCount : 0;
│       
│             setStats({
│               totalHours: totalDuration / 60, // Convert minutes to hours
│               entriesCount,
│               averageEntryDuration: averageEntryDuration / 60, // Convert minutes to hours
│             });
│           } catch (err: any) {
│             setError(err);
│           } finally {
│             setLoading(false);
│           }
│         }, []);
│       
│         useEffect(() => {
│           fetchTimeEntries();
│         }, [fetchTimeEntries]);
│       
│         return { timeEntries, stats, loading, error, fetchTimeEntries };
│       };
└── useTodoLists.ts
        // src/hooks/useTodoLists.ts
        import { useState, useEffect, useCallback } from 'react';
        import type { TodoList } from '@/types';
        import { todoListsApi } from '@/lib/api/todoLists';
        
        interface UseTodoListsReturn {
          todoLists: TodoList[];
          loading: boolean;
          error: Error | null;
          fetchTodoLists: () => Promise<void>;
          refresh: () => Promise<void>; // Added refresh method
        }
        
        export const useTodoLists = (): UseTodoListsReturn => {
          const [todoLists, setTodoLists] = useState<TodoList[]>([]);
          const [loading, setLoading] = useState<boolean>(true);
          const [error, setError] = useState<Error | null>(null);
        
          const fetchTodoLists = useCallback(async () => {
            setLoading(true);
            setError(null);
            try {
              const fetchedTodoLists = await todoListsApi.getTodoLists();
              setTodoLists(fetchedTodoLists);
            } catch (err: any) {
              setError(err);
            } finally {
              setLoading(false);
            }
          }, []);
        
          // Add refresh method that calls fetchTodoLists
          const refresh = useCallback(async () => {
            await fetchTodoLists();
          }, [fetchTodoLists]);
        
          useEffect(() => {
            fetchTodoLists();
          }, [fetchTodoLists]);
        
          return { todoLists, loading, error, fetchTodoLists, refresh };
        };
