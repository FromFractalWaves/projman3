app/
├── api/
│   ├── objectives/
│   │   ├── [id]/
│   │   │   └── route.ts
│   │   │           // src/app/api/objectives/[id]/route.ts
│   │   │           import { NextResponse } from 'next/server';
│   │   │           import { prisma } from '@/lib/prisma';
│   │   │           import type { NextRequest } from 'next/server';
│   │   │           
│   │   │           // DELETE an objective by ID
│   │   │           export async function DELETE(request: Request, { params }: { params: { id: string } }) {
│   │   │             try {
│   │   │               await prisma.objective.delete({
│   │   │                 where: { id: params.id },
│   │   │               });
│   │   │               return NextResponse.json({ message: 'Objective deleted successfully' }, { status: 200 });
│   │   │             } catch (error) {
│   │   │               console.error('Error deleting objective:', error);
│   │   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │   │             }
│   │   │           }
│   │   │           
│   │   │           // PUT update an objective by ID
│   │   │           export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
│   │   │             try {
│   │   │               const data = await request.json();
│   │   │               const { name, description, startDate, dueDate, status, estimatedHours } = data;
│   │   │           
│   │   │               const updatedObjective = await prisma.objective.update({
│   │   │                 where: { id: params.id },
│   │   │                 data: {
│   │   │                   name,
│   │   │                   description,
│   │   │                   startDate: startDate ? new Date(startDate) : undefined,
│   │   │                   dueDate: dueDate ? new Date(dueDate) : undefined,
│   │   │                   status,
│   │   │                   estimatedHours: estimatedHours ? parseFloat(estimatedHours) : undefined,
│   │   │                 },
│   │   │               });
│   │   │           
│   │   │               return NextResponse.json(updatedObjective, { status: 200 });
│   │   │             } catch (error) {
│   │   │               console.error('Error updating objective:', error);
│   │   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │   │             }
│   │   │           }
│   │   └── route.ts
│   │           // src/app/api/objectives/route.ts
│   │           import { NextResponse } from 'next/server';
│   │           import { prisma } from '@/lib/prisma';
│   │           import type { NextRequest } from 'next/server';
│   │           
│   │           // GET all objectives
│   │           export async function GET() {
│   │             try {
│   │               const objectives = await prisma.objective.findMany({
│   │                 include: {
│   │                   project: true,
│   │                   tasks: true,
│   │                 },
│   │               });
│   │               return NextResponse.json(objectives, { status: 200 });
│   │             } catch (error) {
│   │               console.error('Error fetching objectives:', error);
│   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │             }
│   │           }
│   │           
│   │           // POST create a new objective
│   │           export async function POST(request: NextRequest) {
│   │             try {
│   │               const data = await request.json();
│   │               const { name, description, projectId, startDate, dueDate, status, estimatedHours } = data;
│   │           
│   │               if (!name || !projectId) {
│   │                 return NextResponse.json({ message: 'Name and Project ID are required' }, { status: 400 });
│   │               }
│   │           
│   │               const newObjective = await prisma.objective.create({
│   │                 data: {
│   │                   name,
│   │                   description,
│   │                   project: { connect: { id: projectId } },
│   │                   startDate: startDate ? new Date(startDate) : undefined,
│   │                   dueDate: dueDate ? new Date(dueDate) : undefined,
│   │                   status,
│   │                   estimatedHours: estimatedHours ? parseFloat(estimatedHours) : undefined,
│   │                 },
│   │               });
│   │           
│   │               return NextResponse.json(newObjective, { status: 201 });
│   │             } catch (error) {
│   │               console.error('Error creating objective:', error);
│   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │             }
│   │           }
│   ├── projects/
│   │   ├── [id]/
│   │   │   └── route.ts
│   │   │           // src/app/api/projects/[id]/route.ts
│   │   │           import { NextResponse } from 'next/server';
│   │   │           import { prisma } from '@/lib/prisma';
│   │   │           import type { NextRequest } from 'next/server';
│   │   │           
│   │   │           // GET a single project by ID
│   │   │           export async function GET(request: NextRequest, { params }: { params: { id: string } }) {
│   │   │             try {
│   │   │               const project = await prisma.project.findUnique({
│   │   │                 where: { id: params.id },
│   │   │                 include: {
│   │   │                   objectives: true,
│   │   │                   tasks: true,
│   │   │                 },
│   │   │               });
│   │   │           
│   │   │               if (!project) {
│   │   │                 return NextResponse.json({ message: 'Project not found' }, { status: 404 });
│   │   │               }
│   │   │           
│   │   │               return NextResponse.json(project, { status: 200 });
│   │   │             } catch (error) {
│   │   │               console.error('Error fetching project:', error);
│   │   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │   │             }
│   │   │           }
│   │   │           
│   │   │           // DELETE a project by ID
│   │   │           export async function DELETE(request: Request, { params }: { params: { id: string } }) {
│   │   │             try {
│   │   │               await prisma.project.delete({
│   │   │                 where: { id: params.id },
│   │   │               });
│   │   │               return NextResponse.json({ message: 'Project deleted successfully' }, { status: 200 });
│   │   │             } catch (error) {
│   │   │               console.error('Error deleting project:', error);
│   │   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │   │             }
│   │   │           }
│   │   │           
│   │   │           // PUT update a project by ID
│   │   │           export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
│   │   │             try {
│   │   │               const data = await request.json();
│   │   │               const { name, description, startDate, dueDate, status, estimatedHours } = data;
│   │   │           
│   │   │               const updatedProject = await prisma.project.update({
│   │   │                 where: { id: params.id },
│   │   │                 data: {
│   │   │                   name,
│   │   │                   description,
│   │   │                   startDate: startDate ? new Date(startDate) : undefined,
│   │   │                   dueDate: dueDate ? new Date(dueDate) : undefined,
│   │   │                   status,
│   │   │                   estimatedHours: estimatedHours ? parseFloat(estimatedHours) : undefined,
│   │   │                 },
│   │   │               });
│   │   │           
│   │   │               return NextResponse.json(updatedProject, { status: 200 });
│   │   │             } catch (error) {
│   │   │               console.error('Error updating project:', error);
│   │   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │   │             }
│   │   │           }
│   │   └── route.ts
│   │           // src/app/api/projects/route.ts
│   │           import { NextResponse } from 'next/server';
│   │           import { prisma } from '@/lib/prisma';
│   │           import type { NextRequest } from 'next/server';
│   │           
│   │           // GET all projects
│   │           export async function GET() {
│   │             try {
│   │               const projects = await prisma.project.findMany({
│   │                 include: {
│   │                   objectives: true,
│   │                   tasks: true,
│   │                 },
│   │               });
│   │               return NextResponse.json(projects, { status: 200 });
│   │             } catch (error) {
│   │               console.error('Error fetching projects:', error);
│   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │             }
│   │           }
│   │           
│   │           // POST create a new project
│   │           export async function POST(request: NextRequest) {
│   │             try {
│   │               const data = await request.json();
│   │               const { name, description, startDate, dueDate, status, estimatedHours } = data;
│   │           
│   │               if (!name) {
│   │                 return NextResponse.json({ message: 'Name is required' }, { status: 400 });
│   │               }
│   │           
│   │               const newProject = await prisma.project.create({
│   │                 data: {
│   │                   name,
│   │                   description,
│   │                   startDate: startDate ? new Date(startDate) : undefined,
│   │                   dueDate: dueDate ? new Date(dueDate) : undefined,
│   │                   status,
│   │                   estimatedHours: estimatedHours ? parseFloat(estimatedHours) : undefined,
│   │                 },
│   │               });
│   │           
│   │               return NextResponse.json(newProject, { status: 201 });
│   │             } catch (error) {
│   │               console.error('Error creating project:', error);
│   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │             }
│   │           }
│   ├── tasks/
│   │   ├── [id]/
│   │   │   └── route.ts
│   │   │           // src/app/api/tasks/[id]/route.ts
│   │   │           import { NextResponse } from 'next/server';
│   │   │           import { prisma } from '@/lib/prisma';
│   │   │           import type { NextRequest } from 'next/server';
│   │   │           
│   │   │           // DELETE a task by ID
│   │   │           export async function DELETE(request: Request, { params }: { params: { id: string } }) {
│   │   │             try {
│   │   │               await prisma.task.delete({
│   │   │                 where: { id: params.id },
│   │   │               });
│   │   │               return NextResponse.json({ message: 'Task deleted successfully' }, { status: 200 });
│   │   │             } catch (error) {
│   │   │               console.error('Error deleting task:', error);
│   │   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │   │             }
│   │   │           }
│   │   │           
│   │   │           // PUT update a task by ID
│   │   │           export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
│   │   │             try {
│   │   │               const data = await request.json();
│   │   │               const {
│   │   │                 content,
│   │   │                 description,
│   │   │                 status,
│   │   │                 priority,
│   │   │                 projectId,
│   │   │                 objectiveId,
│   │   │                 startDate,
│   │   │                 dueDate,
│   │   │                 estimatedHours,
│   │   │                 actualHours,
│   │   │               } = data;
│   │   │           
│   │   │               const updatedTask = await prisma.task.update({
│   │   │                 where: { id: params.id },
│   │   │                 data: {
│   │   │                   content,
│   │   │                   description,
│   │   │                   status,
│   │   │                   priority,
│   │   │                   project: { connect: { id: projectId } },
│   │   │                   objective: objectiveId ? { connect: { id: objectiveId } } : { disconnect: true },
│   │   │                   startDate: startDate ? new Date(startDate) : undefined,
│   │   │                   dueDate: dueDate ? new Date(dueDate) : undefined,
│   │   │                   estimatedHours: estimatedHours ? parseFloat(estimatedHours) : undefined,
│   │   │                   actualHours: actualHours ? parseFloat(actualHours) : undefined,
│   │   │                 },
│   │   │               });
│   │   │           
│   │   │               return NextResponse.json(updatedTask, { status: 200 });
│   │   │             } catch (error) {
│   │   │               console.error('Error updating task:', error);
│   │   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │   │             }
│   │   │           }
│   │   └── route.ts
│   │           // src/app/api/tasks/route.ts
│   │           import { NextResponse } from 'next/server';
│   │           import { prisma } from '@/lib/prisma';
│   │           import type { NextRequest } from 'next/server';
│   │           
│   │           // GET all tasks
│   │           export async function GET() {
│   │             try {
│   │               const tasks = await prisma.task.findMany({
│   │                 include: {
│   │                   project: true,
│   │                   objective: true,
│   │                   todoLists: true,
│   │                   timeEntries: true,
│   │                 },
│   │               });
│   │               return NextResponse.json(tasks, { status: 200 });
│   │             } catch (error) {
│   │               console.error('Error fetching tasks:', error);
│   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │             }
│   │           }
│   │           
│   │           // POST create a new task
│   │           export async function POST(request: NextRequest) {
│   │             try {
│   │               const data = await request.json();
│   │               const {
│   │                 content,
│   │                 description,
│   │                 status,
│   │                 priority,
│   │                 projectId,
│   │                 objectiveId,
│   │                 startDate,
│   │                 dueDate,
│   │                 estimatedHours,
│   │                 actualHours,
│   │               } = data;
│   │           
│   │               if (!content || !projectId) {
│   │                 return NextResponse.json({ message: 'Content and Project ID are required' }, { status: 400 });
│   │               }
│   │           
│   │               const newTask = await prisma.task.create({
│   │                 data: {
│   │                   content,
│   │                   description,
│   │                   status,
│   │                   priority,
│   │                   project: { connect: { id: projectId } },
│   │                   objective: objectiveId ? { connect: { id: objectiveId } } : undefined,
│   │                   startDate: startDate ? new Date(startDate) : undefined,
│   │                   dueDate: dueDate ? new Date(dueDate) : undefined,
│   │                   estimatedHours: estimatedHours ? parseFloat(estimatedHours) : undefined,
│   │                   actualHours: actualHours ? parseFloat(actualHours) : undefined,
│   │                 },
│   │               });
│   │           
│   │               return NextResponse.json(newTask, { status: 201 });
│   │             } catch (error) {
│   │               console.error('Error creating task:', error);
│   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │             }
│   │           }
│   ├── time-entries/
│   │   └── route.ts
│   │           // src/app/api/time_entries/route.ts
│   │           import { NextResponse } from 'next/server';
│   │           import { prisma } from '@/lib/prisma';
│   │           import type { NextRequest } from 'next/server';
│   │           
│   │           // GET all time entries
│   │           export async function GET() {
│   │             try {
│   │               const timeEntries = await prisma.timeEntry.findMany({
│   │                 include: {
│   │                   task: true,
│   │                 },
│   │               });
│   │               return NextResponse.json(timeEntries, { status: 200 });
│   │             } catch (error) {
│   │               console.error('Error fetching time entries:', error);
│   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │             }
│   │           }
│   │           
│   │           // POST create a new time entry
│   │           export async function POST(request: NextRequest) {
│   │             try {
│   │               const data = await request.json();
│   │               const { taskId, startTime, endTime, description } = data;
│   │           
│   │               if (!taskId || !startTime) {
│   │                 return NextResponse.json({ message: 'Task ID and Start Time are required' }, { status: 400 });
│   │               }
│   │           
│   │               const duration = endTime ? (new Date(endTime).getTime() - new Date(startTime).getTime()) / (1000 * 60) : undefined; // Duration in minutes
│   │           
│   │               const newTimeEntry = await prisma.timeEntry.create({
│   │                 data: {
│   │                   task: { connect: { id: taskId } },
│   │                   startTime: new Date(startTime),
│   │                   endTime: endTime ? new Date(endTime) : undefined,
│   │                   duration,
│   │                   description,
│   │                 },
│   │               });
│   │           
│   │               return NextResponse.json(newTimeEntry, { status: 201 });
│   │             } catch (error) {
│   │               console.error('Error creating time entry:', error);
│   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │             }
│   │           }
│   ├── todo_lists/
│   │   ├── [id]/
│   │   │   └── route.ts
│   │   │           // src/app/api/todo_lists/[id]/route.ts
│   │   │           import { NextResponse } from 'next/server';
│   │   │           import { prisma } from '@/lib/prisma';
│   │   │           import type { NextRequest } from 'next/server';
│   │   │           
│   │   │           // DELETE a todo list by ID
│   │   │           export async function DELETE(request: Request, { params }: { params: { id: string } }) {
│   │   │             try {
│   │   │               await prisma.todoList.delete({
│   │   │                 where: { id: params.id },
│   │   │               });
│   │   │               return NextResponse.json({ message: 'Todo List deleted successfully' }, { status: 200 });
│   │   │             } catch (error) {
│   │   │               console.error('Error deleting todo list:', error);
│   │   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │   │             }
│   │   │           }
│   │   │           
│   │   │           // PUT update a todo list by ID
│   │   │           export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
│   │   │             try {
│   │   │               const data = await request.json();
│   │   │               const { name, type } = data;
│   │   │           
│   │   │               const updatedTodoList = await prisma.todoList.update({
│   │   │                 where: { id: params.id },
│   │   │                 data: {
│   │   │                   name,
│   │   │                   type,
│   │   │                 },
│   │   │               });
│   │   │           
│   │   │               return NextResponse.json(updatedTodoList, { status: 200 });
│   │   │             } catch (error) {
│   │   │               console.error('Error updating todo list:', error);
│   │   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │   │             }
│   │   │           }
│   │   └── route.ts
│   │           // src/app/api/todo_lists/route.ts
│   │           import { NextResponse } from 'next/server';
│   │           import { prisma } from '@/lib/prisma';
│   │           import type { NextRequest } from 'next/server';
│   │           
│   │           // GET all todo lists
│   │           export async function GET() {
│   │             try {
│   │               const todoLists = await prisma.todoList.findMany({
│   │                 include: {
│   │                   tasks: true,
│   │                 },
│   │               });
│   │               return NextResponse.json(todoLists, { status: 200 });
│   │             } catch (error) {
│   │               console.error('Error fetching todo lists:', error);
│   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │             }
│   │           }
│   │           
│   │           // POST create a new todo list
│   │           export async function POST(request: NextRequest) {
│   │             try {
│   │               const data = await request.json();
│   │               const { name, type } = data;
│   │           
│   │               if (!name) {
│   │                 return NextResponse.json({ message: 'Name is required' }, { status: 400 });
│   │               }
│   │           
│   │               const newTodoList = await prisma.todoList.create({
│   │                 data: {
│   │                   name,
│   │                   type: type || 'daily',
│   │                 },
│   │               });
│   │           
│   │               return NextResponse.json(newTodoList, { status: 201 });
│   │             } catch (error) {
│   │               console.error('Error creating todo list:', error);
│   │               return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│   │             }
│   │           }
│   └── todo_tasks/
│       ├── [todoListId]/
│       │   └── [taskId]/
│       │       └── route.ts
│       │               // src/app/api/todo_tasks/[todoListId]/[taskId]/route.ts
│       │               import { NextResponse } from 'next/server';
│       │               import { prisma } from '@/lib/prisma';
│       │               import type { NextRequest } from 'next/server';
│       │               
│       │               // DELETE a task from a todo list
│       │               export async function DELETE(request: Request, { params }: { params: { todoListId: string; taskId: string } }) {
│       │                 try {
│       │                   await prisma.todoList.update({
│       │                     where: { id: params.todoListId },
│       │                     data: {
│       │                       tasks: {
│       │                         disconnect: { id: params.taskId },
│       │                       },
│       │                     },
│       │                   });
│       │                   return NextResponse.json({ message: 'Task removed from Todo List successfully' }, { status: 200 });
│       │                 } catch (error) {
│       │                   console.error('Error removing task from todo list:', error);
│       │                   return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│       │                 }
│       │               }
│       │               
│       │               // POST associate a task with a todo list
│       │               export async function POST(request: NextRequest, { params }: { params: { todoListId: string; taskId: string } }) {
│       │                 try {
│       │                   const { todoListId, taskId } = params;
│       │               
│       │                   await prisma.todoList.update({
│       │                     where: { id: todoListId },
│       │                     data: {
│       │                       tasks: {
│       │                         connect: { id: taskId },
│       │                       },
│       │                     },
│       │                   });
│       │               
│       │                   return NextResponse.json({ message: 'Task added to Todo List successfully' }, { status: 200 });
│       │                 } catch (error) {
│       │                   console.error('Error adding task to todo list:', error);
│       │                   return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });
│       │                 }
│       │               }
│       └── route.ts
│               // app/api/todo_tasks/route.ts
│               import { NextResponse } from 'next/server'
│               import { prisma } from '@/lib/prisma'
│               
│               export async function POST(request: Request) {
│                 const json = await request.json()
│                 const task = await prisma.task.update({
│                   where: { id: json.taskId },
│                   data: {
│                     todoLists: {
│                       connect: { id: json.todoListId },
│                     },
│                   },
│                 })
│                 return NextResponse.json(task)
│               }
├── dashboard/
│   └── page.tsx
├── favicon.ico
├── globals.css
├── home/
│   └── page.tsx
├── layout.tsx
│       import type { Metadata } from "next";
│       import { Geist, Geist_Mono } from "next/font/google";
│       import "./globals.css";
│       
│       const geistSans = Geist({
│         variable: "--font-geist-sans",
│         subsets: ["latin"],
│       });
│       
│       const geistMono = Geist_Mono({
│         variable: "--font-geist-mono",
│         subsets: ["latin"],
│       });
│       
│       export const metadata: Metadata = {
│         title: "Create Next App",
│         description: "Generated by create next app",
│       };
│       
│       export default function RootLayout({
│         children,
│       }: Readonly<{
│         children: React.ReactNode;
│       }>) {
│         return (
│           <html lang="en" className="dark">
│             <body
│               className={`${geistSans.variable} ${geistMono.variable} min-h-screen bg-background text-foreground antialiased`}
│             >
│               {children}
│             </body>
│           </html>
│         );
│       }
├── notepad/
│   └── page.tsx
│           // src/app/notepad/page.tsx
│           'use client';
│           
│           import React, { useState, useEffect } from 'react';
│           import { Save } from 'lucide-react';
│           import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui';
│           import { Button } from '@/components/ui/button';
│           
│           export default function NotepadPage() {
│             const [text, setText] = useState('');
│             const [savedText, setSavedText] = useState('');
│             const [showSaved, setShowSaved] = useState(false);
│           
│             // Load saved content from localStorage on mount
│             useEffect(() => {
│               const saved = localStorage.getItem('notepad-content');
│               if (saved) {
│                 setText(saved);
│                 setSavedText(saved);
│               }
│             }, []);
│           
│             // Handle text changes
│             const handleTextChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
│               setText(e.target.value);
│               setShowSaved(false);
│             };
│           
│             // Save content to localStorage
│             const handleSave = () => {
│               localStorage.setItem('notepad-content', text);
│               setSavedText(text);
│               setShowSaved(true);
│               setTimeout(() => setShowSaved(false), 2000);
│             };
│           
│             // Handle keyboard shortcuts
│             const handleKeyDown = (e: React.KeyboardEvent) => {
│               if (e.ctrlKey && e.key === 's') {
│                 e.preventDefault();
│                 handleSave();
│               }
│             };
│           
│             return (
│               <div className="min-h-screen bg-black p-6">
│                 <Card className="bg-zinc-900 border-zinc-800">
│                   <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
│                     <CardTitle className="text-white">Notepad</CardTitle>
│                     <Button 
│                       onClick={handleSave}
│                       className="bg-blue-600 hover:bg-blue-700 text-white flex items-center gap-2"
│                     >
│                       <Save className="h-4 w-4" />
│                       Save
│                     </Button>
│                   </CardHeader>
│                   <CardContent>
│                     {showSaved && (
│                       <div className="mb-4 p-2 bg-emerald-900/50 text-emerald-400 rounded-md border border-emerald-800">
│                         Changes saved successfully!
│                       </div>
│                     )}
│           
│                     <textarea
│                       className="w-full p-4 bg-zinc-800 border border-zinc-700 rounded-md resize-none 
│                                focus:outline-none focus:ring-2 focus:ring-blue-500 text-zinc-100 font-mono
│                                min-h-[calc(100vh-16rem)]"
│                       value={text}
│                       onChange={handleTextChange}
│                       onKeyDown={handleKeyDown}
│                       spellCheck={true}
│                       placeholder="Start typing... (Ctrl+S to save)"
│                     />
│           
│                     <div className="mt-4 text-sm text-zinc-400 flex justify-between">
│                       <span>{text.length} characters</span>
│                       <span>{text.split(/\s+/).filter(Boolean).length} words</span>
│                     </div>
│                   </CardContent>
│                 </Card>
│               </div>
│             );
│           }
├── objectives/
│   └── page.tsx
│           
│           // src/app/objectives/page.tsx
│           'use client';
│           
│           import React from 'react';
│           import { useObjectives } from '@/hooks/useObjectives';
│           import { ObjectiveForm } from '@/components/forms';
│           import { useProjects } from '@/hooks/useProjects';
│           
│           export default function ObjectivesPage() {
│             const { objectives, loading } = useObjectives();
│             const { projects } = useProjects();
│           
│             if (loading) return <div>Loading...</div>;
│           
│             return (
│               <div className="p-8">
│                 <h1 className="text-3xl font-bold mb-6">Objectives</h1>
│                 <ObjectiveForm onSubmit={() => {}} projects={projects} />
│                 <div className="mt-6 space-y-4">
│                   {objectives.map((objective) => (
│                     <div key={objective.id} className="p-4 bg-gray-800 rounded-lg">
│                       <h3 className="text-xl font-semibold">{objective.name}</h3>
│                       <p className="text-gray-400">{objective.description}</p>
│                     </div>
│                   ))}
│                 </div>
│               </div>
│             );
│           }
├── page.tsx
│       'use client';
│       
│       import React from 'react';
│       import { useProjects } from '@/hooks/useProjects';
│       import { useObjectives } from '@/hooks/useObjectives';
│       import { useTasks } from '@/hooks/useTasks';
│       import { useTodoLists } from '@/hooks/useTodoLists';
│       import { DashboardLayout } from '@/components/dashboard/DashboardLayout';
│       import { QuickAddDialogs } from '@/components/dialogs';
│       import { PROJECT_STATUS, TASK_STATUS } from '@/constants';
│       import Link from 'next/link';
│       import { Button } from '@/components/ui/button';
│       import { Menu, FileEdit, Clock } from 'lucide-react';
│       
│       export default function Home() {
│         const { 
│           projects, 
│           loading: projectsLoading, 
│           error: projectsError,
│           createProject,
│           refresh: refreshProjects 
│         } = useProjects();
│         
│         const { 
│           objectives, 
│           loading: objectivesLoading, 
│           error: objectivesError,
│           createObjective,
│           refresh: refreshObjectives 
│         } = useObjectives();
│         
│         const { 
│           tasks, 
│           loading: tasksLoading, 
│           error: tasksError,
│           createTask,
│           refresh: refreshTasks 
│         } = useTasks();
│         
│         const {
│           todoLists,
│           loading: todoListsLoading,
│           error: todoListsError,
│           refresh: refreshTodoLists
│         } = useTodoLists();
│       
│         const isLoading = projectsLoading || objectivesLoading || tasksLoading || todoListsLoading;
│         const hasError = projectsError || objectivesError || tasksError || todoListsError;
│       
│         // Handle loading and error states
│         if (isLoading || hasError) {
│           return (
│             <div className="flex min-h-screen items-center justify-center bg-neutral-900">
│               <div className="text-xl text-neutral-100">
│                 {isLoading ? (
│                   'Loading dashboard...'
│                 ) : (
│                   <span className="text-red-500">
│                     Error loading dashboard data. Please try again later.
│                   </span>
│                 )}
│               </div>
│             </div>
│           );
│         }
│       
│         // Refresh all data
│         const handleRefresh = async () => {
│           await Promise.all([
│             refreshProjects(),
│             refreshObjectives(),
│             refreshTasks(),
│             refreshTodoLists()
│           ]);
│         };
│       
│         // Filter active projects
│         const activeProjects = projects.filter(
│           project => project.status !== PROJECT_STATUS.COMPLETED
│         );
│       
│         // Calculate task statistics
│         const taskStats = {
│           todo: tasks.filter(task => task.status === TASK_STATUS.TODO).length,
│           inProgress: tasks.filter(task => task.status === TASK_STATUS.IN_PROGRESS).length,
│           done: tasks.filter(task => task.status === TASK_STATUS.DONE).length,
│         };
│       
│         const handleTimeEntryAdd = async (data) => {
│           console.log('Time entry to be implemented', data);
│           await handleRefresh();
│         };
│       
│         return (
│           <div className="min-h-screen bg-neutral-900">
│             {/* Header with Navigation */}
│             <div className="border-b border-neutral-800 bg-neutral-900/50 backdrop-blur-sm sticky top-0 z-50">
│               <div className="flex items-center justify-between px-4 py-3">
│                 <h1 className="text-xl font-bold text-white">Dashboard</h1>
│                 <div className="flex items-center gap-4">
│                   <Button variant="ghost" size="sm" asChild>
│                     <Link href="/projects">Projects</Link>
│                   </Button>
│                   <Button variant="ghost" size="sm" asChild>
│                     <Link href="/objectives">Objectives</Link>
│                   </Button>
│                   <Button variant="ghost" size="sm" asChild>
│                     <Link href="/tasks">Tasks</Link>
│                   </Button>
│                   <Button variant="ghost" size="sm" asChild>
│                     <Link href="/time">Time</Link>
│                   </Button>
│                   <Button variant="ghost" size="sm" asChild>
│                     <Link href="/todo">Todo</Link>
│                   </Button>
│                   <Button variant="ghost" size="sm" asChild>
│                     <Link href="/timeline">Timeline</Link>
│                   </Button>
│                   <Button variant="ghost" size="sm" asChild className="flex items-center gap-2">
│                     <Link href="/notepad">
│                       <span className="flex items-center gap-2">
│                         <FileEdit className="h-4 w-4" />
│                         Notes
│                       </span>
│                     </Link>
│                   </Button>
│                 </div>
│               </div>
│             </div>
│       
│             <div className="p-4">
│               {/* Quick Add Section */}
│               <QuickAddDialogs
│                 projects={projects}
│                 objectives={objectives}
│                 tasks={tasks.filter(t => t.status !== 'done')}
│                 onProjectAdd={createProject}
│                 onObjectiveAdd={createObjective}
│                 onTaskAdd={createTask}
│                 onTimeEntryAdd={handleTimeEntryAdd}
│               />
│       
│               {/* Dashboard Layout */}
│               <DashboardLayout 
│                 projects={projects}
│                 objectives={objectives}
│                 tasks={tasks}
│                 todoLists={todoLists}
│                 taskStats={taskStats}
│                 onRefresh={handleRefresh}
│               />
│             </div>
│           </div>
│         );
│       }
├── page.tsx.md
├── projects/
│   └── page.tsx
│           // src/app/projects/page.tsx
│           'use client';
│           
│           import React from 'react';
│           import { useProjects } from '@/hooks/useProjects';
│           import { ProjectForm } from '@/components/forms';
│           
│           export default function ProjectsPage() {
│             const { projects, loading } = useProjects();
│           
│             if (loading) return <div>Loading...</div>;
│           
│             return (
│               <div className="p-8">
│                 <h1 className="text-3xl font-bold mb-6">Projects</h1>
│                 <ProjectForm onSubmit={() => {}} />
│                 <div className="mt-6 space-y-4">
│                   {projects.map((project) => (
│                     <div key={project.id} className="p-4 bg-gray-800 rounded-lg">
│                       <h3 className="text-xl font-semibold">{project.name}</h3>
│                       <p className="text-gray-400">{project.description}</p>
│                     </div>
│                   ))}
│                 </div>
│               </div>
│             );
│           }
├── tasks/
│   └── page.tsx
│           
│           // src/app/tasks/page.tsx
│           'use client';
│           
│           import React from 'react';
│           import { useTasks } from '@/hooks/useTasks';
│           import { TaskForm } from '@/components/forms';
│           import { useProjects } from '@/hooks/useProjects';
│           import { useObjectives } from '@/hooks/useObjectives';
│           
│           export default function TasksPage() {
│             const { tasks, loading } = useTasks();
│             const { projects } = useProjects();
│             const { objectives } = useObjectives();
│           
│             if (loading) return <div>Loading...</div>;
│           
│             return (
│               <div className="p-8">
│                 <h1 className="text-3xl font-bold mb-6">Tasks</h1>
│                 <TaskForm onSubmit={() => {}} projects={projects} objectives={objectives} />
│                 <div className="mt-6 space-y-4">
│                   {tasks.map((task) => (
│                     <div key={task.id} className="p-4 bg-gray-800 rounded-lg">
│                       <h3 className="text-xl font-semibold">{task.content}</h3>
│                       <p className="text-gray-400">{task.description}</p>
│                     </div>
│                   ))}
│                 </div>
│               </div>
│             );
│           }
├── time/
│   └── page.tsx
│           
│           // src/app/time/page.tsx
│           'use client';
│           
│           import React from 'react';
│           import { useTimeEntries } from '@/hooks/useTimeEntries';
│           import { TimeEntryForm } from '@/components/forms';
│           import { useTasks } from '@/hooks/useTasks';
│           
│           export default function TimePage() {
│             const { timeEntries, loading } = useTimeEntries();
│             const { tasks } = useTasks();
│           
│             if (loading) return <div>Loading...</div>;
│           
│             return (
│               <div className="p-8">
│                 <h1 className="text-3xl font-bold mb-6">Time Tracking</h1>
│                 <TimeEntryForm onSubmit={() => {}} tasks={tasks} />
│                 <div className="mt-6 space-y-4">
│                   {timeEntries.map((entry) => (
│                     <div key={entry.id} className="p-4 bg-gray-800 rounded-lg">
│                       <h3 className="text-xl font-semibold">
│                         {entry.task?.content || 'Unknown Task'}
│                       </h3>
│                       <p className="text-gray-400">{entry.description}</p>
│                     </div>
│                   ))}
│                 </div>
│               </div>
│             );
│           }
├── timeline/
│   └── page.tsx
│           // src/app/timeline/page.tsx
│           'use client';
│           
│           import React from 'react';
│           import { Timeline } from '@/components/ui/timeline/Timeline';
│           import { useProjects } from '@/hooks/useProjects';
│           import { useObjectives } from '@/hooks/useObjectives';
│           import { useTasks } from '@/hooks/useTasks';
│           import { useTimeline } from '@/hooks/useTimeline';
│           import { useRouter } from 'next/navigation';
│           import { TimelineEvent } from '@/types/timeline';
│           
│           export default function TimelinePage() {
│             const router = useRouter();
│             const { projects, loading: projectsLoading } = useProjects();
│             const { objectives, loading: objectivesLoading } = useObjectives();
│             const { tasks, loading: tasksLoading } = useTasks();
│           
│             const { events } = useTimeline({ projects, objectives, tasks });
│           
│             const handleEventClick = (event: TimelineEvent) => {
│               // Navigate to the respective page based on event type
│               switch (event.type) {
│                 case 'project':
│                   router.push(`/projects/${event.entityId}`);
│                   break;
│                 case 'objective':
│                   router.push(`/objectives/${event.entityId}`);
│                   break;
│                 case 'task':
│                   router.push(`/tasks/${event.entityId}`);
│                   break;
│               }
│             };
│           
│             if (projectsLoading || objectivesLoading || tasksLoading) {
│               return (
│                 <div className="flex min-h-screen items-center justify-center bg-neutral-900">
│                   <div className="text-xl text-neutral-100">Loading timeline...</div>
│                 </div>
│               );
│             }
│           
│             return (
│               <div className="min-h-screen bg-neutral-900 p-8">
│                 <Timeline events={events} onEventClick={handleEventClick} />
│               </div>
│             );
│           }
└── todo/
    └── page.tsx
            
            // src/app/todo/page.tsx
            'use client';
            
            import React from 'react';
            import { useTodoLists } from '@/hooks/useTodoLists';
            import { TodoListForm } from '@/components/forms';
            
            export default function TodoPage() {
              const { todoLists, loading } = useTodoLists();
            
              if (loading) return <div>Loading...</div>;
            
              return (
                <div className="p-8">
                  <h1 className="text-3xl font-bold mb-6">Todo Lists</h1>
                  <TodoListForm onSubmit={() => {}} />
                  <div className="mt-6 space-y-4">
                    {todoLists.map((list) => (
                      <div key={list.id} className="p-4 bg-gray-800 rounded-lg">
                        <h3 className="text-xl font-semibold">{list.name}</h3>
                        <p className="text-gray-400">Type: {list.type}</p>
                        <p className="text-gray-400">Tasks: {list.tasks?.length || 0}</p>
                      </div>
                    ))}
                  </div>
                </div>
              );
            }
